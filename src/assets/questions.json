{
  "source": "https://www.dsfaisal.com/blog/sql/leetcode-sql-problem-solving",
  "title": "LeetCode SQL Problem Solving Questions With Solutions | Blog",
  "published": "2020-11-06T00:00:00.000Z",
  "tags": [
    "SQL",
    "SQL Problem Solving",
    "LeetCode"
  ],
  "total_problems": 153,
  "scraped_at": "2026-02-23T10:55:57.612Z",
  "problems": [
    {
      "section_id": "175-combine-two-tables--easy--leetcode",
      "id": 175,
      "title": "Combine Two Tables",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/combine-two-tables/",
      "description": "Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:",
      "tables": [
        "Person",
        "Address"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT p.FirstName, p.LastName, a.City, a.State\nFROM Person p\nLEFT JOIN Address a\nON p.PersonId = a.PersonId;"
        }
      ]
    },
    {
      "section_id": "176-second-highest-salary--easy--leetcode",
      "id": 176,
      "title": "Second Highest Salary",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/second-highest-salary/",
      "description": "Write a SQL query to get the second highest salary from the Employee table. For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT Max(Salary) SecondHighestSalary\nFROM Employee WHERE Salary < (SELECT MAX(Salary) FROM Employee)\n\n#Solution 2:\nWITH CTE AS (SELECT DISTINCT Salary\nFROM Employee\nORDER BY Salary DESC\nLIMIT 2)\n\nSELECT Salary as SecondHighestSalary\nFROM CTE\nORDER BY Salary Asc\nLIMIT 1;\n\n#Solution 3:\nWITH CTE AS\n(\n    SELECT Salary,\n           DENSE_RANK() OVER (ORDER BY Salary DESC) AS DENSERANK\n    FROM Employee\n)\nSELECT Salary SecondHighestSalary\nFROM CTE\nWHERE DENSERANK = 2;"
        }
      ]
    },
    {
      "section_id": "177-nth-highest-salary--medium--leetcode",
      "id": 177,
      "title": "Nth Highest Salary",
      "difficulty": "Medium",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/nth-highest-salary/",
      "description": "Write a SQL query to get the nth highest salary from the Employee table. For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\nSET N = N-1;\n    RETURN(\n        SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC\n        LIMIT 1 OFFSET N\n    );\nEND"
        }
      ]
    },
    {
      "section_id": "178-rank-scores--medium--leetcode",
      "id": 178,
      "title": "Rank Scores",
      "difficulty": "Medium",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/rank-scores/",
      "description": "Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \"holes\" between ranks. For example, given the above Scores table, your query should generate the following report (order by highest score): Important Note: For MySQL solutions, to escape reserved words used as column names, you can use an apostrophe before and after the keyword. For example Rank.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT score, DENSE_RANK() OVER (ORDER By Score DESC) AS \"Rank\"\nFROM Scores;"
        }
      ]
    },
    {
      "section_id": "180-consecutive-numbers--medium--leetcode",
      "id": 180,
      "title": "Consecutive Numbers",
      "difficulty": "Medium",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/consecutive-numbers/",
      "description": "Write an SQL query to find all numbers that appear at least three times consecutively. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Logs"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT a.Num as ConsecutiveNums\nFROM Logs a\nJOIN Logs b\nON a.id = b.id+1 AND a.num = b.num\nJOIN Logs c\nON a.id = c.id+2 AND a.num = c.num;"
        }
      ]
    },
    {
      "section_id": "181-employees-earning-more-than-their-managers--easy--leetcode",
      "id": 181,
      "title": "Employees Earning More Than Their Managers",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/employees-earning-more-than-their-managers/",
      "description": "The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT E.Name as \"Employee\"\nFROM Employee E\nJOIN Employee M\nON E.ManagerId = M.Id\nAND E.Salary > M.Salary;"
        }
      ]
    },
    {
      "section_id": "182-duplicate-emails--easy--leetcode",
      "id": 182,
      "title": "Duplicate Emails",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/duplicate-emails/",
      "description": "Write a SQL query to find all duplicate emails in a table named Person. For example, your query should return the following for the above table: Note: All emails are in lowercase.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT Email\nFROM Person\nGROUP BY Email\nHAVING count(*) > 1\n\n#Solution- 2:\nWITH CTE AS(\nSELECT Email, ROW_NUMBER() OVER(PARTITION BY Email ORDER BY Email) AS RN\n    FROM Person\n)\n\nSELECT Email\nFROM CTE\nWHERE RN > 1;"
        }
      ]
    },
    {
      "section_id": "183-customers-who-never-order--easy--leetcode",
      "id": 183,
      "title": "Customers Who Never Order",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/customers-who-never-order/",
      "description": "Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Using the above tables as example, return the following:",
      "tables": [
        "Customers.",
        "Orders."
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT Name AS Customers\nFROM Customers\nLEFT JOIN Orders\nON Customers.Id = Orders.CustomerId\nWHERE CustomerId IS NULL;\n\n#Solution- 2:\nSELECT Name as Customers\nFROM Customers\nWHERE Id NOT IN(\n    SELECT CustomerId\n    FROM Orders\n)"
        }
      ]
    },
    {
      "section_id": "184-department-highest-salary--medium--leetcode",
      "id": 184,
      "title": "Department Highest Salary",
      "difficulty": "Medium",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/department-highest-salary/",
      "description": "The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id. The Department table holds all departments of the company. Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter). Explanation: Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT Department.Name AS Department, Employee.Name AS Employee, Salary\nFROM Employee\nJOIN Department\nON Employee.DepartmentId = Department.Id\nWHERE (DepartmentId, Salary) IN(\n        SELECT  DepartmentId, MAX(Salary) AS Salary\n        FROM Employee\n        GROUP BY DepartmentId\n        );"
        }
      ]
    },
    {
      "section_id": "185-department-top-three-salaries--hard--leetcode",
      "id": 185,
      "title": "Department Top Three Salaries",
      "difficulty": "Hard",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/department-top-three-salaries/",
      "description": "The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. The Department table holds all departments of the company. Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter). Explanation: In IT department, Max earns the highest salary, both Randy and Joe earn the second highest salary, and Will earns the third highest salary. There are only two employees in the Sales department, Henry earns the highest salary while Sam earns the second highest salary.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH department_ranking AS (\nSELECT Name AS Employee, Salary ,DepartmentId\n  ,DENSE_RANK() OVER (PARTITION BY DepartmentId ORDER BY Salary DESC) AS rnk\nFROM Employee\n)\n\nSELECT d.Name AS Department, r.Employee, r.Salary\nFROM department_ranking AS r\nJOIN Department AS d\nON r.DepartmentId = d.Id\nWHERE r.rnk <= 3\nORDER BY d.Name ASC, r.Salary DESC;"
        }
      ]
    },
    {
      "section_id": "196-delete-duplicate-emails--easy--leetcode",
      "id": 196,
      "title": "Delete Duplicate Emails",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/delete-duplicate-emails/",
      "description": "Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. Id is the primary key column for this table. For example, after running your query, the above Person table should have the following rows: Note: Your output is the whole Person table after executing your sql. Use delete statement.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "DELETE p2\nFROM Person p1\nJOIN Person p2\nON p1.Email = p2.Email\nAND p1.id < p2.id"
        }
      ]
    },
    {
      "section_id": "197-rising-temperature--easy--leetcode",
      "id": 197,
      "title": "Rising Temperature",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/rising-temperature/",
      "description": "Write an SQL query to find all dates' id with higher temperature compared to its previous dates (yesterday). Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Weather"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT t.Id\nFROM Weather AS t, Weather AS y\nWHERE DATEDIFF(t.RecordDate, y.RecordDate) = 1\nAND t.Temperature > y.Temperature;\n\n#Solution- 2:\nSELECT t.Id\nFROM Weather t\nJOIN Weather y\nON DATEDIFF(t.recordDate, y.recordDate) = 1 AND\nt.temperature > y.temperature;"
        }
      ]
    },
    {
      "section_id": "262-trips-and-users--hard--leetcode",
      "id": 262,
      "title": "Trips and Users",
      "difficulty": "Hard",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/trips-and-users/",
      "description": "Write a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day. Return the result table in any order. Round Cancellation Rate to two decimal points. The query result format is in the following example:",
      "tables": [
        "Trips",
        "Users"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT Request_at AS Day,\nROUND(SUM(IF(Status<>\"completed\", 1, 0))/COUNT(Status),2) AS \"Cancellation Rate\"\nFROM Trips\nWHERE Request_at BETWEEN \"2013-10-01\" AND \"2013-10-03\"\nAND Client_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = 'Yes')\nAND Driver_Id NOT IN (SELECT Users_Id FROM Users WHERE Banned = 'Yes')\nGROUP BY Request_at;"
        }
      ]
    },
    {
      "section_id": "511-game-play-analysis-i--easy---leetcode",
      "id": 511,
      "title": "Game Play Analysis I",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/game-play-analysis-i/",
      "description": "Write an SQL query that reports the first login date for each player. The query result format is in the following example:",
      "tables": [
        "Activity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT player_id, MIN(event_date) as first_login\nFROM Activity\nGROUP BY player_id"
        }
      ]
    },
    {
      "section_id": "512-game-play-analysis-ii--easy---leetcode",
      "id": 512,
      "title": "Game Play Analysis II",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/game-play-analysis-ii/",
      "description": "Write a SQL query that reports the device that is first logged in for each player. The query result format is in the following example:",
      "tables": [
        "Activity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT DISTINCT player_id, device_id\nFROM Activity\nWHERE (player_id, event_date) in (\n    SELECT player_id, min(event_date)\n    FROM Activity\n    GROUP BY player_id)\n\n#Solution- 2:\nSELECT a.player_id, b.device_id\nFROM\n(SELECT player_id, MIN(event_date) AS event_date FROM Activity\nGROUP BY player_id) a\nJOIN Activity b\nON a.player_id = b.player_id AND a.event_date = b.event_date;\n\n#Solution- 3:\nSELECT player_id, device_id\nFROM\n(SELECT player_id, device_id, event_date,\nROW_NUMBER() OVER (PARTITION BY player_id ORDER BY event_date) AS r\nFROM Activity) lookup\nWHERE r = 1;"
        }
      ]
    },
    {
      "section_id": "534-game-play-analysis-iii--medium---leetcode",
      "id": 534,
      "title": "Game Play Analysis III",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/game-play-analysis-iii/",
      "description": "Write an SQL query that reports for each player and date, how many games played so far by the player. That is, the total number of games played by the player until that date. Check the example for clarity. The query result format is in the following example:",
      "tables": [
        "Activity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT t1.player_id, t1.event_date, SUM(t2.games_played) as games_played_so_far\nFROM Activity t1\nJOIN Activity t2\nON t1.player_id = t2.player_id\nWHERE t1.event_date >= t2.event_date\nGROUP BY t1.player_id, t1.event_date;\n\n#Solution- 2:\nSELECT player_id, event_date,\nSUM(games_played) OVER (PARTITION BY player_id ORDER BY event_date) AS games_played_so_far\nFROM Activity;"
        }
      ]
    },
    {
      "section_id": "550-game-play-analysis-iv--medium---leetcode",
      "id": 550,
      "title": "Game Play Analysis IV",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/game-play-analysis-iv/",
      "description": "Write an SQL query that reports the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players. The query result format is in the following example:",
      "tables": [
        "Activity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT ROUND(sum(CASE WHEN t1.event_date = t2.first_event+1 THEN 1 ELSE 0 END)/COUNT(DISTINCT t1.player_id), 2) AS fraction\nFROM Activity t1\nJOIN\n    (SELECT player_id, MIN(event_date) AS first_event\n    FROM Activity\n    GROUP BY player_id) t2\n    ON t1.player_id = t2.player_id;\n\n#Solution- 2:\nSELECT ROUND(COUNT(DISTINCT b.player_id)/COUNT(DISTINCT a.player_id),2) AS fraction\nFROM\n  (SELECT player_id, MIN(event_date) AS event_date FROM Activity\n  GROUP BY player_id) a\n  LEFT JOIN Activity b\n  ON a.player_id = b.player_id AND a.event_date+1 = b.event_date;"
        }
      ]
    },
    {
      "section_id": "569-median-employee-salary--hard---leetcode",
      "id": 569,
      "title": "Median Employee Salary",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/median-employee-salary/",
      "description": "The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary. Write a SQL query to find the median salary of each company. Bonus points if you can solve it without using any built-in SQL functions.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT t1.Id AS Id, t1.Company, t1.Salary\nFROM Employee AS t1 JOIN Employee AS t2\nON t1.Company = t2.Company\nGROUP BY t1.Id\nHAVING abs(sum(CASE WHEN t2.Salary<t1.Salary THEN 1\n                  WHEN t2.Salary>t1.Salary THEN -1\n                  WHEN t2.Salary=t1.Salary AND t2.Id<t1.Id THEN 1\n                  WHEN t2.Salary=t1.Salary AND t2.Id>t1.Id THEN -1\n                  ELSE 0 END)) <= 1\nORDER BY t1.Company, t1.Salary, t1.Id"
        }
      ]
    },
    {
      "section_id": "570-managers-with-at-least-5-direct-reports--medium---leetcode",
      "id": 570,
      "title": "Managers with at Least 5 Direct Reports",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/",
      "description": "The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. Given the Employee table, write a SQL query that finds out managers with at least 5 direct report. For the above table, your SQL query should return: Note: No one would report to himself.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT Name\nFROM Employee\nWHERE id IN\n   (SELECT ManagerId\n    FROM Employee\n    GROUP BY ManagerId\n    HAVING COUNT(DISTINCT Id) >= 5)"
        }
      ]
    },
    {
      "section_id": "571-find-median-given-frequency-of-numbers---leetcode",
      "id": 571,
      "title": "Find Median Given Frequency of Numbers",
      "difficulty": "ðŸ”’ LeetCode",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/find-median-given-frequency-of-numbers/",
      "description": "The Numbers table keeps the value of number and its frequency. In this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median is (0 + 0) / 2 = 0. Write a query to find the median of all numbers and name the result as median.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT avg(t3.Number) as median\nFROM Numbers as t3\nJOIN\n    (SELECT t1.Number,\n        abs(SUM(CASE WHEN t1.Number>t2.Number THEN t2.Frequency ELSE 0 END) -\n            SUM(CASE WHEN t1.Number<t2.Number THEN t2.Frequency ELSE 0 END)) AS count_diff\n    FROM numbers AS t1, numbers AS t2\n    GROUP BY t1.Number) AS t4\nON t3.Number = t4.Number\nWHERE t3.Frequency>=t4.count_diff"
        }
      ]
    },
    {
      "section_id": "574-winning-candidate--medium---leetcode",
      "id": 574,
      "title": "Winning Candidate",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/winning-candidate/",
      "description": "id is the auto-increment primary key, CandidateId is the id appeared in Candidate table. Write a sql to find the name of the winning candidate, the above example will return the winner B. Notes: You may assume there is no tie, in other words there will be at most one winning candidate.",
      "tables": [
        "Candidate",
        "Vote"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT Name\nFROM Candidate\nWHERE id = (SELECT CandidateId\n     FROM Vote\n     GROUP BY CandidateId\n     ORDER BY COUNT(1) desc\n     LIMIT 1)\n\n## Assumption: if we have two candidates with the same votes, we choose the one who get the first vote\n# SELECT Name\n# FROM Candidate JOIN\n#     (SELECT CandidateId\n#     FROM Vote\n#     GROUP BY CandidateId\n#     ORDER BY count(1) DESC\n#     LIMIT 1) AS t\n# ON Candidate.id = t.CandidateId"
        }
      ]
    },
    {
      "section_id": "577-employee-bonus--easy---leetcode",
      "id": 577,
      "title": "Employee Bonus",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/employee-bonus/https://leetcode.com/problems/employee-bonus/",
      "description": "Select all employeeâ€™s name and bonus whose bonus is < 1000. Example ouput:",
      "tables": [
        "Employee",
        "Bonus"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT name, bonus\nFROM Employee LEFT JOIN Bonus\nON Employee.empId = Bonus.empId\nWHERE bonus<1000 OR bonus IS NULL;"
        }
      ]
    },
    {
      "section_id": "578-get-highest-answer-rate-question--medium---leetcode",
      "id": 578,
      "title": "Get Highest Answer Rate Question",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/get-highest-answer-rate-question/",
      "description": "Get the highest answer rate question from a table survey_log with these columns: uid, action, question_id, answer_id, q_num, timestamp. uid means user id; action has these kind of values: â€œshowâ€, â€œanswerâ€, â€œskipâ€; answer_id is not null when action column is â€œanswerâ€, while is null for â€œshowâ€ and â€œskipâ€; q_num is the numeral order of the question in current session. Write a sql query to identify the question which has the highest answer rate. Example: Input: Output: Explanation: question 285 has answer rate 1/1, while question 369 has 0/1 answer rate, so output 285. Note: The highest answer rate meaning is: answer numberâ€™s ratio in show number in the same question.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1::\nSELECT question_id AS survey_log FROM\n(SELECT question_id,\n        SUM(IF(action='show', 1, 0)) AS num_show,\n        SUM(IF(action='answer', 1, 0)) AS num_answer\n FROM survey_log GROUP BY question_id) AS t\nORDER BY (num_answer/num_show) DESC LIMIT 1;\n\n#Solution- 2:\nSELECT question_id AS survey_log\nFROM (SELECT question_id,\n      sum(CASE WHEN  action='show' THEN 1 ELSE 0 END) AS show_count,\n      sum(CASE WHEN  action='answer' THEN 1 ELSE 0 END) AS answer_count\n    FROM survey_log\n    GROUP BY question_id) AS t\nORDER BY answer_count/show_count DESC LIMIT 1;"
        }
      ]
    },
    {
      "section_id": "579-find-cumulative-salary-of-an-employee--hard---leetcode",
      "id": 579,
      "title": "Find Cumulative Salary of an Employee",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-cumulative-salary-of-an-employee/",
      "description": "The Employee table holds the salary information in a year. Write a SQL to get the cumulative sum of an employeeâ€™s salary over a period of 3 months but exclude the most recent month. The result should be displayed by â€˜Idâ€™ ascending, and then by â€˜Monthâ€™ descending. Example Input Output Explanation Employee â€˜1â€™ has 3 salary records for the following 3 months except the most recent month â€˜4â€™: salary 40 for month â€˜3â€™, 30 for month â€˜2â€™ and 20 for month â€˜1â€™ So the cumulative sum of salary of this employee over 3 months is 90(40+30+20), 50(30+20) and 20 respectively. Employee â€˜2â€™ only has one salary record (month â€˜1â€™) except its most recent month â€˜2â€™. Employ â€˜3â€™ has two salary records except its most recent pay month â€˜4â€™: month â€˜3â€™ with 60 and month â€˜2â€™ with 40. So the cumulative salary is as following.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\n    a.id,\n    a.month,\n    SUM(b.salary) Salary\nFROM\n    Employee a JOIN Employee b ON\n    a.id = b.id AND\n    a.month - b.month >= 0 AND\n    a.month - b.month < 3\nGROUP BY\n    a.id, a.month\nHAVING\n    (a.id, a.month) NOT IN (SELECT id, MAX(month) FROM Employee GROUP BY id)\nORDER BY\n    a.id, a.month DESC"
        }
      ]
    },
    {
      "section_id": "580-count-student-number-in-departments--medium---leetcode",
      "id": 580,
      "title": "Count Student Number in Departments",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/count-student-number-in-departments/",
      "description": "A university uses 2 data tables, student and department, to store data about its students and the departments associated with each major. Write a query to print the respective department name and number of students majoring in each department for all departments in the department table (even ones with no current students). Sort your results by descending number of students; if two or more departments have the same number of students, then sort those departments alphabetically by department name. The student is described as follow: where student_id is the studentâ€™s ID number, student_name is the studentâ€™s name, gender is their gender, and dept_id is the department ID associated with their declared major. And the department table is described as below: where dept_id is the departmentâ€™s ID number and dept_name is the department name. Here is an example input: student table: department table: The Output should be:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT dept_name,\n  SUM(CASE WHEN student_id IS NULL THEN 0 ELSE 1 END) AS student_number\nFROM department\nLEFT JOIN student\nON department.dept_id = student.dept_id\nGROUP BY department.dept_id\nORDER BY student_number DESC, dept_name"
        }
      ]
    },
    {
      "section_id": "584-find-customer-referee--easy---leetcode",
      "id": 584,
      "title": "Find Customer Referee",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-customer-referee/",
      "description": "Given a table customer holding customers information and the referee. Write a query to return the list of customers NOT referred by the person with id â€˜2â€™. For the sample data above, the result is:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT name\nFROM customer\nWHERE referee_id != '2' OR referee_id IS NULL;"
        }
      ]
    },
    {
      "section_id": "585-investments-in-2016--medium---leetcode",
      "id": 585,
      "title": "Investments in 2016",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/investments-in-2016/",
      "description": "Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria: where PID is the policyholderâ€™s policy ID, TIV_2015 is the total investment value in 2015, TIV_2016 is the total investment value in 2016, LAT is the latitude of the policy holderâ€™s city, and LON is the longitude of the policy holderâ€™s city. Sample Input Sample Output Explanation",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT SUM(TIV_2016) AS TIV_2016\nFROM insurance\nWHERE CONCAT(LAT, ',', LON)\n    IN (SELECT CONCAT(LAT, ',', LON)\n       FROM insurance\n       GROUP BY LAT, LON\n       HAVING COUNT(1) = 1)\nAND TIV_2015 in\n    (SELECT TIV_2015\n    FROM insurance\n    GROUP BY TIV_2015\n    HAVING COUNT(1)>1)"
        }
      ]
    },
    {
      "section_id": "586-customer-placing-the-largest-number-of-orders--easy---leetcode",
      "id": 586,
      "title": "Customer Placing the Largest Number of Orders",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/",
      "description": "Query the customer_number from the orders table for the customer who has placed the largest number of orders. It is guaranteed that exactly one customer will have placed more orders than any other customer. The orders table is defined as follows: Sample Input Sample Output Explanation",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "# assume: only one match\nSELECT customer_number FROM orders\nGROUP BY customer_number\nORDER BY COUNT(1) DESC\nLIMIT 1\n\n## assume: multiple matches\n##  1 1\n##  2 1\n##  3 1\n##\n##  1 1 1 1\n##  1 1 2 1\n##  1 1 3 1\n##\n##  SELECT t1.customer_number\n##  FROM (SELECT customer_number, COUNT(1) AS count\n##        FROM orders GROUP BY customer_number) AS t1,\n##        (SELECT customer_number, COUNT(1) AS count\n##        FROM orders GROUP BY customer_number) AS t2\n##  GROUP BY t1.customer_number\n##  HAVING max(t1.count) = max(t2.count)"
        }
      ]
    },
    {
      "section_id": "595-big-countries--easy--leetcode",
      "id": 595,
      "title": "Big Countries",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/big-countries/",
      "description": "There is a table World A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million. Write a SQL solution to output big countries' name, population and area. For example, according to the above table, we should output:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT name, population, area\nFROM World\nWHERE area >= 3000000 OR population > 25000000;"
        }
      ]
    },
    {
      "section_id": "596-classes-more-than-5-students--easy--leetcode",
      "id": 596,
      "title": "Classes More Than 5 Students",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/classes-more-than-5-students/",
      "description": "There is a table courses with columns: student and class Please list out all classes which have more than or equal to 5 students. For example, the table: Should output:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT class\nFROM courses\nGROUP BY class\nHAVING count(DISTINCT Student)>=5;"
        }
      ]
    },
    {
      "section_id": "597-friend-requests-i-overall-acceptance-rate--easy---leetcode",
      "id": 597,
      "title": "Friend Requests I: Overall Acceptance Rate",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/friend-requests-i-overall-acceptance-rate/",
      "description": "In social network like Facebook or Twitter, people send friend requests and accept othersâ€™ requests as well. Now given two tables as below: Table: friend_request Write a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests. For the sample data above, your query should return the following result. Note: The accepted requests are not necessarily from the table friend_request. In this case, you just need to simply count the total accepted requests (no matter whether they are in the original requests), and divide it by the number of requests to get the acceptance rate. It is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the â€˜duplicatedâ€™ requests or acceptances are only counted once. If there is no requests at all, you should return 0.00 as the accept_rate. Explanation: There are 4 unique accepted requests, and there are 5 requests in total. So the rate is 0.80. Follow-up: Can you write a query to return the accept rate but for every month? How about the cumulative accept rate for every day?",
      "tables": [
        "request_accepted"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT IFNULL((round(accepts/requests, 2)), 0.0) AS accept_rate\nFROM\n    (SELECT count(DISTINCT sender_id, send_to_id) AS requests FROM friend_request) AS t1,\n    (SELECT count(DISTINCT requester_id, accepter_id) AS accepts FROM request_accepted) AS t2"
        }
      ]
    },
    {
      "section_id": "601-human-traffic-of-stadium--hard--leetcode",
      "id": 601,
      "title": "Human Traffic of Stadium",
      "difficulty": "Hard",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/human-traffic-of-stadium/",
      "description": "visit_date is the primary key for this table. Each row of this table contains the visit date and visit id to the stadium with the number of people during the visit. No two rows will have the same visit_date, and as the id increases, the dates increase as well. Write an SQL query to display the records with three or more rows with consecutive id's, and the number of people is greater than or equal to 100 for each. Return the result table ordered by visit_date in ascending order. The query result format is in the following example.",
      "tables": [
        "Stadium"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT DISTINCT s1.*\nFROM Stadium s1 JOIN Stadium s2 JOIN Stadium s3\nON (s1.id = s2.id-1 AND s1.id = s3.id-2) OR\n (s1.id = s2.id+1 AND s1.id = s3.id-1) OR\n (s1.id = s2.id+1 AND s1.id = s3.id+2)\n    WHERE s1.people >= 100 AND s2.people >= 100 AND s3.people>=100\n  ORDER BY visit_date"
        }
      ]
    },
    {
      "section_id": "602-friend-requests-ii-who-has-the-most-friends--medium---leetcode",
      "id": 602,
      "title": "Friend Requests II: Who Has the Most Friends",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends/",
      "description": "In social network like Facebook or Twitter, people send friend requests and accept othersâ€™ requests as well. Table request_accepted holds the data of friend acceptance, while requester_id and accepter_id both are the id of a person. Write a query to find the the people who has most friends and the most friends number. For the sample data above, the result is: Note: It is guaranteed there is only 1 people having the most friends. The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value. Explanation: The person with id â€˜3â€™ is a friend of people â€˜1â€™, â€˜2â€™ and â€˜4â€™, so he has 3 friends in total, which is the most number than any others. Follow-up: In the real world, multiple people could have the same most number of friends, can you find all these people in this case?",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT t.id, sum(t.num) AS num\nFROM (\n      (SELECT requester_id AS id, COUNT(1) AS num\n       FROM request_accepted\n       GROUP BY requester_id)\n      union all\n       (SELECT accepter_id AS id, COUNT(1) AS num\n        FROM request_accepted\n        GROUP BY accepter_id)) AS t\nGROUP BY t.id\nORDER BY num DESC\nLIMIT 1;"
        }
      ]
    },
    {
      "section_id": "603-consecutive-available-seats--easy---leetcode",
      "id": 603,
      "title": "Consecutive Available Seats",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/consecutive-available-seats/",
      "description": "Several friends at a cinema ticket office would like to reserve consecutive available seats. Can you help to query all the consecutive available seats order by the seat_id using the following cinema table? Your query should return the following result for the sample case above. Note: The seat_id is an auto increment int, and free is bool (â€˜1â€™ means free, and â€˜0â€™ means occupied.). Consecutive available seats are more than 2(inclusive) seats consecutively available.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT DISTINCT t1.seat_id\nFROM cinema AS t1 JOIN cinema AS t2\nON abs(t1.seat_id-t2.seat_id)=1\nWHERE t1.free='1' AND t2.free='1'\nORDER BY t1.seat_id"
        }
      ]
    },
    {
      "section_id": "607sales-person--easy---leetcode",
      "id": 607,
      "title": "Sales Person",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/sales-person/",
      "description": "Description Given three tables: salesperson, company, orders. Output all the names in the table salesperson, who didnâ€™t have sales to company â€˜REDâ€™. Example Input The table salesperson holds the salesperson information. Every salesperson has a sales_id and a name. Table: company The table company holds the company information. Every company has a com_id and a name. Table: orders The table orders holds the sales record information, salesperson and customer company are represented by sales_id and com_id. output Explanation According to order â€˜3â€™ and â€˜4â€™ in table orders, it is easy to tell only salesperson â€˜Johnâ€™ and â€˜Alexâ€™ have sales to company â€˜REDâ€™, so we need to output all the other names in table salesperson.",
      "tables": [
        "salesperson"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT name\nFROM salesperson\nWHERE name NOT IN\n    (SELECT DISTINCT salesperson.name\n    FROM salesperson, orders, company\n    WHERE company.name = 'RED'\n    AND salesperson.sales_id = orders.sales_id\n    AND orders.com_id = company.com_id)"
        }
      ]
    },
    {
      "section_id": "608-tree-node--medium---leetcode",
      "id": 608,
      "title": "Tree Node",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/tree-node/",
      "description": "Given a table tree, id is identifier of the tree node and p_id is its parent nodeâ€™s id. Each node in the tree can be one of three types: Leaf: if the node is a leaf node. Root: if the node is the root of the tree. Inner: If the node is neither a leaf node nor a root node. Write a query to print the node id and the type of the node. Sort your output by the node id. The result for the above sample is: Explanation Node â€˜1â€™ is root node, because its parent node is NULL and it has child node â€˜2â€™ and â€˜3â€™. Node â€˜2â€™ is inner node, because it has parent node â€˜1â€™ and child node â€˜4â€™ and â€˜5â€™. Node â€˜3â€™, â€˜4â€™ and â€˜5â€™ is Leaf node, because they have parent node and they donâ€™t have child node. And here is the image of the sample tree as below: Note If there is only one node on the tree, you only need to output its root attributes.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "## Basic Ideas: LEFT JOIN\n# In tree, each node can only one parent or no parent\n## | id | p_id | id (child) |\n## |----+------+------------|\n## |  1 | null |          1 |\n## |  1 | null |          2 |\n## |  2 |    1 |          4 |\n## |  2 |    1 |          5 |\n## |  3 |    1 |       null |\n## |  4 |    2 |       null |\n## |  5 |    2 |       null |\n\nSELECT t1.id,\n    CASE\n        WHEN ISNULL(t1.p_id) THEN 'Root'\n        WHEN ISNULL(MAX(t2.id)) THEN 'Leaf'\n        ELSE 'Inner'\n    END AS Type\nFROM tree AS t1 LEFT JOIN tree AS t2\nON t1.id = t2.p_id\nGROUP BY t1.id, t1.p_id"
        }
      ]
    },
    {
      "section_id": "610-triangle-judgement--easy---leetcode",
      "id": 610,
      "title": "Triangle Judgement",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/triangle-judgement/",
      "description": "A pupil Tim gets homework to identify whether three line segments could possibly form a triangle. However, this assignment is very heavy because there are hundreds of records to calculate. Could you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table triangle holds the length of the three sides x, y and z. For the sample data above, your query should return the follow result:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT x, y, z,\n       CASE\n           WHEN x+y>z AND y+z>x AND x+z>y THEN 'Yes'\n           ELSE 'No'\n       END AS triangle\nFROM triangle"
        }
      ]
    },
    {
      "section_id": "612-shortest-distance-in-a-plane--medium---leetcode",
      "id": 612,
      "title": "Shortest Distance in a Plane",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/shortest-distance-in-a-plane/",
      "description": "Table point_2d holds the coordinates (x,y) of some unique points (more than two) in a plane. Write a query to find the shortest distance between these points rounded to 2 decimals. The shortest distance is 1.00 from point (-1,-1) to (-1,2). So the output should be: Note: The longest distance among all the points are less than 10000.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT ROUND(MIN(SQRT((t1.x-t2.x)*(t1.x-t2.x) + (t1.y-t2.y)*(t1.y-t2.y))), 2) as shortest\nFROM point_2d AS t1, point_2d AS t2\nWHERE t1.x!=t2.x OR t1.y!=t2.y\n\n# SELECT ROUND(SQRT((t1.x-t2.x)*(t1.x-t2.x) + (t1.y-t2.y)*(t1.y-t2.y)), 2) AS shortest\n# FROM point_2d AS t1, point_2d AS t2\n# WHERE t1.x!=t2.x OR t1.y!=t2.y\n# ORDER BY shortest ASC\n# LIMIT 1"
        }
      ]
    },
    {
      "section_id": "613-shortest-distance-in-a-line--easy---leetcode",
      "id": 613,
      "title": "Shortest Distance in a Line",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/shortest-distance-in-a-line/",
      "description": "Table point holds the x coordinate of some points on x-axis in a plane, which are all integers. Write a query to find the shortest distance between two points in these points. The shortest distance is â€˜1â€™ obviously, which is from point â€˜-1â€™ to â€˜0â€™. So the output is as below: Note: Every point is unique, which means there is no duplicates in table point. Follow-up: What if all these points have an id and are arranged from the left most to the right most of x axis?",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT t1.x-t2.x AS shortest\nFROM point AS t1 JOIN point AS t2\nWHERE t1.x>t2.x\nORDER BY (t1.x-t2.x) ASC\nLIMIT 1"
        }
      ]
    },
    {
      "section_id": "614-second-degree-follower--medium---leetcode",
      "id": 614,
      "title": "Second Degree Follower",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/second-degree-follower/",
      "description": "In facebook, there is a follow table with two columns: followee, follower. Please write a sql query to get the amount of each followerâ€™s follower if he/she has one. For example: should output: Explanation: Both B and D exist in the follower list, when as a followee, Bâ€™s follower is C and D, and Dâ€™s follower is E. A does not exist in follower list. Note: Followee would not follow himself/herself in all cases. Please display the result in followerâ€™s alphabet order.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "## Explain the business logic\n##   A follows B. Then A is follwer, B is followee\n## What are second degree followers?\n##   A follows B, and B follows C.\n##   Then A is the second degree followers of C\n\nSELECT f1.follower, COUNT(DISTINCT f2.follower) AS num\nFROM follow AS f1 JOIN follow AS f2\nON f1.follower = f2.followee\nGROUP BY f1.follower;"
        }
      ]
    },
    {
      "section_id": "615-average-salary-departments-vs-company--hard---leetcode",
      "id": 615,
      "title": "Average Salary: Departments VS Company",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/average-salary-departments-vs-company",
      "description": "Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the companyâ€™s average salary. Table: salary The employee_id column refers to the employee_id in the following table employee. So for the sample data above, the result is: Explanation In March, the companyâ€™s average salary is (9000+6000+10000)/3 = 8333.33â€¦ The average salary for department â€˜1â€™ is 9000, which is the salary of employee_id â€˜1â€™ since there is only one employee in this department. So the comparison result is â€˜higherâ€™ since 9000 > 8333.33 obviously. The average salary of department â€˜2â€™ is (6000 + 10000)/2 = 8000, which is the average of employee_id â€˜2â€™ and â€˜3â€™. So the comparison result is â€˜lowerâ€™ since 8000 < 8333.33. With he same formula for the average salary comparison in February, the result is â€˜sameâ€™ since both the department â€˜1â€™ and â€˜2â€™ have the same average salary with the company, which is 7000.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT t1.pay_month, t1.department_id,\n    (CASE WHEN t1.amount = t2.amount THEN 'same'\n          WHEN t1.amount > t2.amount THEN 'higher'\n          WHEN t1.amount < t2.amount THEN 'lower' END) AS comparison\nFROM\n    (SELECT left(pay_date, 7) AS pay_month, department_id, avg(amount) AS amount\n    FROM salary JOIN employee\n    ON salary.employee_id = employee.employee_id\n    GROUP BY pay_month, department_id\n    ORDER BY pay_month DESC, department_id) AS t1\n    JOIN\n    (SELECT left(pay_date, 7) AS pay_month, avg(amount) AS amount\n    FROM salary JOIN employee\n    ON salary.employee_id = employee.employee_id\n    GROUP BY pay_month) AS t2\n    ON t1.pay_month = t2.pay_month"
        }
      ]
    },
    {
      "section_id": "618-students-report-by-geography--hard---leetcode",
      "id": 618,
      "title": "Students Report By Geography",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/students-report-by-geography",
      "description": "A U.S graduate school has students from Asia, Europe and America. The studentsâ€™ location information are stored in table student as below. Pivot the continent column in this table so that each name is sorted alphabetically and displayed underneath its corresponding continent. The output headers should be America, Asia and Europe respectively. It is guaranteed that the student number from America is no less than either Asia or Europe. For the sample input, the output is: Follow-up: If it is unknown which continent has the most students, can you write a query to generate the student report?",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT t1.name AS America, t2.name AS Asia, t3.name AS Europe\nFROM\n    (SELECT (@cnt1 := @cnt1 + 1) AS id, name\n    FROM student\n    CROSS JOIN (SELECT @cnt1 := 0) AS dummy\n    WHERE continent='America'\n    ORDER BY name) AS t1\n    LEFT JOIN\n    (SELECT (@cnt2 := @cnt2 + 1) AS id, name\n    FROM student\n    CROSS JOIN (SELECT @cnt2 := 0) AS dummy\n    WHERE continent='Asia'\n    ORDER BY name) AS t2\n    ON t1.id = t2.id\n    LEFT JOIN\n    (SELECT (@cnt3 := @cnt3 + 1) AS id, name\n    FROM student\n    CROSS JOIN (SELECT @cnt3 := 0) AS dummy\n    WHERE continent='Europe'\n    ORDER BY name) AS t3\n    ON t1.id = t3.id"
        }
      ]
    },
    {
      "section_id": "619-biggest-single-number--easy---leetcode",
      "id": 619,
      "title": "Biggest Single Number",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/biggest-single-number",
      "description": "Table number contains many numbers in column num including duplicated ones. Can you write a SQL query to find the biggest number, which only appears once. For the sample data above, your query should return the following result: Note: If there is no such number, just output null.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT IFNULL((\n    SELECT num\n    FROM number\n    GROUP BY num\n    HAVING count(1) = 1\n    ORDER BY num DESC\n    LIMIT 0, 1), NULL) AS num"
        }
      ]
    },
    {
      "section_id": "620-not-boring-movies--easy--leetcode",
      "id": 620,
      "title": "Not Boring Movies",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/not-boring-movies/",
      "description": "X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the moviesâ€™ ratings and descriptions. Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating. For example, table cinema: For the example above, the output should be:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT *\nFROM Cinema\nWHERE description <> 'boring' AND ID % 2 = 1\nORDER BY rating DESC;"
        }
      ]
    },
    {
      "section_id": "626-exchange-seats--medium--leetcode",
      "id": 626,
      "title": "Exchange Seats",
      "difficulty": "Medium",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/exchange-seats/",
      "description": "Mary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary? For the sample input, the output is: Note: If the number of students is odd, there is no need to change the last one's seat.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\nIF(id<(SELECT MAX(id) FROM seat),IF(id%2=0,id-1, id+1),IF(id%2=0, id-1, id)) AS id, student\nFROM seat\nORDER BY id;"
        }
      ]
    },
    {
      "section_id": "627-swap-salary--leetcode",
      "id": 627,
      "title": "Swap Salary",
      "difficulty": "LeetCode",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/swap-salary/",
      "description": "Write an SQL query to swap all 'f' and 'm' values (i.e., change all 'f' values to 'm' and vice versa) with a single update statement and no intermediate temp table(s). Note that you must write a single update statement, DO NOT write any select statement for this problem. The query result format is in the following example:",
      "tables": [
        "Salary"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "# With IF\nUPDATE Salary SET sex = IF(sex='m', 'f', 'm')\n\n# With CASE\nUPDATE Salary SET sex = CASE WHEN sex='m' THEN 'f' ELSE 'm' END"
        }
      ]
    },
    {
      "section_id": "1045-customers-who-bought-all-products--medium---leetcode",
      "id": 1045,
      "title": "Customers Who Bought All Products",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/customers-who-bought-all-products",
      "description": "product_key is a foreign key to Product table. Table: Product Write an SQL query for a report that provides the customer ids from the Customer table that bought all the products in the Product table. For example:",
      "tables": [
        "Customer"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT customer_id\nFROM Customer\nGROUP NY customer_id\nHAVING count(DISTINCT product_key) = (\n    SELECT count(1)\n    FROM Product)"
        }
      ]
    },
    {
      "section_id": "1050-actors-and-directors-who-cooperated-at-least-three-times--easy---leetcode",
      "id": 1050,
      "title": "Actors and Directors Who Cooperated At Least Three Times",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times",
      "description": "Write a SQL query for a report that provides the pairs (actor_id, director_id) where the actor have cooperated with the director at least 3 times. Example:",
      "tables": [
        "ActorDirector"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT actor_id, director_id\nFROM ActorDirector\nGROUP BY actor_id, director_id\nHAVING COUNT(1)>=3"
        }
      ]
    },
    {
      "section_id": "1068-product-sales-analysis-i--easy---leetcode",
      "id": 1068,
      "title": "Product Sales Analysis I",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/product-sales-analysis-i",
      "description": "Write an SQL query that reports all product names of the products in the Sales table along with their selling year and price. For example:",
      "tables": [
        "Sales",
        "Product"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT product_name, year, price\nFROM Sales JOIN Product\nON Product.product_id = Sales.product_id"
        }
      ]
    },
    {
      "section_id": "1069-product-sales-analysis-ii--easy---leetcode",
      "id": 1069,
      "title": "Product Sales Analysis II",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/product-sales-analysis-ii",
      "description": "Write an SQL query that reports the total quantity sold for every product id. The query result format is in the following example:",
      "tables": [
        "Sales",
        "Product"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT product_id, sum(quantity) AS total_quantity\nFROM Sales\nGROUP BY product_id;"
        }
      ]
    },
    {
      "section_id": "1070-product-sales-analysis-iii--medium---leetcode",
      "id": 1070,
      "title": "Product Sales Analysis III",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/product-sales-analysis-iii",
      "description": "Write an SQL query that selects the product id, year, quantity, and price for the first year of every product sold. The query result format is in the following example:",
      "tables": [
        "Sales",
        "Product"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\n    product_id,\n    year first_year,\n    quantity,\n    price\nFROM Sales\nWHERE (product_id, year) IN (SELECT product_id, MIN(year)\n                             FROM Sales\n                             GROUP BY product_id)"
        }
      ]
    },
    {
      "section_id": "1075-project-employees-i--easy---leetcode",
      "id": 1075,
      "title": "Project Employees I",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/project-employees-i",
      "description": "Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits. The query result format is in the following example:",
      "tables": [
        "Project",
        "Employee"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\n    p.project_id,\n    ROUND(AVG(e.experience_years),2) average_years\nFROM\n    Project p JOIN Employee e ON\n    p.employee_id = e.employee_id\nGROUP BY\n    p.project_id"
        }
      ]
    },
    {
      "section_id": "1076-project-employees-ii--easy---leetcode",
      "id": 1076,
      "title": "Project Employees II",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/project-employees-ii",
      "description": "Write an SQL query that reports all the projects that have the most employees. The query result format is in the following example:",
      "tables": [
        "Project",
        "Employee"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT project_id\nFROM Project\nGROUP BY project_id\nHAVING COUNT(employee_id) = (SELECT COUNT(employee_id)\n                            FROM Project\n                            GROUP BY project_id\n                            ORDER BY COUNT(employee_id) DESC\n                            LIMIT 1)"
        }
      ]
    },
    {
      "section_id": "1077-project-employees-iii--medium---leetcode",
      "id": 1077,
      "title": "Project Employees III",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/project-employees-iii",
      "description": "Write an SQL query that reports the most experienced employees in each project. In case of a tie, report all employees with the maximum number of experience years. The query result format is in the following example:",
      "tables": [
        "Project",
        "Employee"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\n    p.project_id,\n    e.employee_id\nFROM\n    Project p LEFT JOIN Employee e ON\n    p.employee_id = e.employee_id\nWHERE (p.project_id,\n       e.experience_years) IN (SELECT\n                                p.project_id,\n                                MAX(e.experience_years)\n                            FROM\n                                Project p JOIN Employee e ON\n                                p.employee_id = e.employee_id\n                            GROUP BY\n                                p.project_id)"
        }
      ]
    },
    {
      "section_id": "1082-sales-analysis-i--easy---leetcode",
      "id": 1082,
      "title": "Sales Analysis I",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/sales-analysis-i",
      "description": "Write an SQL query that reports the best seller by total sales price, If there is a tie, report them all. The query result format is in the following example:",
      "tables": [
        "Product",
        "Sales"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT seller_id\nFROM Sales\nGROUP BY seller_id\nHAVING SUM(price) = (SELECT SUM(price)\n                    FROM Sales\n                    GROUP BY seller_id\n                    ORDER BY SUM(price) DESC\n                    LIMIT 1)"
        }
      ]
    },
    {
      "section_id": "1083-sales-analysis-ii--easy---leetcode",
      "id": 1083,
      "title": "Sales Analysis II",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/sales-analysis-ii",
      "description": "Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table. The query result format is in the following example:",
      "tables": [
        "Product",
        "Sales"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT DISTINCT s.buyer_id\nFROM Sales s LEFT JOIN Product p ON\n    s.product_id = p.product_id\nWHERE p.product_name = 'S8' AND\n      s.buyer_id NOT IN (SELECT s.buyer_id\n                        FROM Sales s LEFT JOIN Product p ON\n                            s.product_id = p.product_id\n                        WHERE p.product_name = 'iPhone')"
        }
      ]
    },
    {
      "section_id": "1084-sales-analysis-iii--easy---leetcode",
      "id": 1084,
      "title": "Sales Analysis III",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/sales-analysis-iii",
      "description": "Reports the products that were only sold in spring 2019. That is, between 2019-01-01 and 2019-03-31 inclusive. Select the product that were only sold in spring 2019.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "(SELECT DISTINCT s.product_id, p.product_name\nFROM Sales s LEFT JOIN Product p ON\n    s.product_id = p.product_id\nWHERE s.sale_date >= '2019-01-01' AND\n      s.sale_date <= '2019-03-31')\nEXCEPT -- MINUS if Oracle\n(SELECT DISTINCT s.product_id, p.product_name\nFROM Sales s LEFT JOIN Product p ON\n    s.product_id = p.product_id\nWHERE s.sale_date < '2019-01-01' OR\n      s.sale_date > '2019-03-31')"
        }
      ]
    },
    {
      "section_id": "1097-game-play-analysis-v--hard---leetcode",
      "id": 1097,
      "title": "Game Play Analysis V",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/game-play-analysis-v",
      "description": "We define the install date of a player to be the first login day of that player. We also define day 1 retention of some date X to be the number of players whose install date is X and they logged back in on the day right after X , divided by the number of players whose install date is X, rounded to 2 decimal places. Write an SQL query that reports for each install date, the number of players that installed the game on that day and the day 1 retention. The query result format is in the following example:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\n    install_dt,\n    COUNT(player_id) installs,\n    ROUND(COUNT(retention)/COUNT(player_id),2) Day1_retention  --the number of record on the next day / the total number of id on the day = retention rate\nFROM\n    (\n    SELECT a.player_id, a.install_dt, b.event_date retention -- id, the record of the first installation day and next day\n    FROM\n        (SELECT player_id, MIN(event_date) install_dt   --subquery 1 take the first installation of date of each id\n        FROM Activity\n        GROUP BY player_id) a LEFT JOIN Activity b ON   --sq1 left join the original table, find the login status the next day after the first installation\n            a.player_id = b.player_id AND\n            a.install_dt + 1=b.event_date\n    ) AS tmp\nGROUP BY\n    install_dt"
        }
      ]
    },
    {
      "section_id": "1098-unpopular-books--medium---leetcode",
      "id": 1098,
      "title": "Unpopular Books",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/unpopular-books",
      "description": "Write an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than 1 month from today. Assume today is 2019-06-23. The query result format is in the following example:",
      "tables": [
        "Books",
        "Orders"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\n    b.book_id, b.name\nFROM\n    Books b LEFT JOIN (                    -- subquery calculates last year's sales\n        SELECT book_id, SUM(quantity) nsold\n        FROM Orders\n        WHERE dispatch_date BETWEEN '2018-06-23' AND '2019-06-23'\n        GROUP BY book_id\n    ) o\n    ON b.book_id = o.book_id\nWHERE\n    (o.nsold < 10 OR o.nsold IS NULL) AND           -- Sales less than 10 or no sales\n    DATEDIFF('2019-06-23', b.available_from) > 30   -- Not a new book within 1 month"
        }
      ]
    },
    {
      "section_id": "1107-new-users-daily-count--medium---leetcode",
      "id": 1107,
      "title": "New Users Daily Count",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/new-users-daily-count",
      "description": "Write an SQL query that reports for every date within at most 90 days from today, the number of users that logged in for the first time on that date. Assume today is 2019-06-30. The query result format is in the following example:",
      "tables": [
        "Traffic"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT login_date, COUNT(user_id) AS user_count\nFROM (SELECT user_id, MIN(activity_date) AS login_date\n    FROM Traffic\n    WHERE activity = 'login'\n    GROUP BY user_id) AS t\nWHERE login_date >= DATE_ADD('2019-06-30', INTERVAL -90 DAY) AND login_date <= '2019-06-30'\nGROUP BY login_date\n\n#Solution- 2:\nSELECT login_date, COUNT(user_id) user_count\nFROM\n    (SELECT user_id, MIN(activity_date) as login_date\n    FROM Traffic\n    WHERE activity='login'\n    GROUP BY user_id) as t\nWHERE DATEDIFF('2019-06-30', login_date) <= 90\nGROUP BY login_date"
        }
      ]
    },
    {
      "section_id": "1112-highest-grade-for-each-student--medium---leetcode",
      "id": 1112,
      "title": "Highest Grade For Each Student",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/highest-grade-for-each-student",
      "description": "Write a SQL query to find the highest grade with its corresponding course for each student. In case of a tie, you should find the course with the smallest course_id. The output must be sorted by increasing student_id. The query result format is in the following example:",
      "tables": [
        "Enrollments"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT student_id, MIN(course_id) course_id, grade\nFROM Enrollments\nWHERE (student_id, grade) IN\n        (SELECT student_id, MAX(grade)\n        FROM Enrollments\n        GROUP BY student_id)\nGROUP BY student_id\nORDER BY student_id;"
        }
      ]
    },
    {
      "section_id": "1113reported-posts--easy---leetcode",
      "id": 1113,
      "title": "Reported Posts",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/reported-posts",
      "description": "Write an SQL query that reports the number of posts reported yesterday for each report reason. Assume today is 2019-07-05. The query result format is in the following example: Note that we only care about report reasons with non zero number of reports.",
      "tables": [
        "Actions"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT extra report_reason, COUNT(DISTINCT post_id) report_count\nFROM\n    (SELECT post_id, extra\n    FROM Actions\n    WHERE action_date = DATE_SUB('2019-07-05', INTERVAL 1 DAY) AND\n          action = 'report') AS tmp\nGROUP BY extra"
        }
      ]
    },
    {
      "section_id": "1126-active-businesses--medium---leetcode",
      "id": 1126,
      "title": "Active Businesses",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/active-businesses",
      "description": "Write an SQL query to find all active businesses. An active business is a business that has more than one event type with occurences greater than the average occurences of that event type among all businesses. The query result format is in the following example:",
      "tables": [
        "Events"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT business_id\nFROM (SELECT a.business_id, a.event_type, a.occurences, b.event_avg  -- sub 2\n      FROM Events a LEFT JOIN\n        (SELECT event_type, AVG(occurences) event_avg   -- sub 1\n         FROM Events\n         GROUP BY event_type) b ON\n      a.event_type = b.event_type) tmp\nWHERE occurences > event_avg\nGROUP BY business_id\nHAVING COUNT(event_type) > 1"
        }
      ]
    },
    {
      "section_id": "1127-user-purchase-platform--hard---leetcode",
      "id": 1127,
      "title": "User Purchase Platform",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/user-purchase-platform",
      "description": "Write an SQL query to find the total number of users and the total amount spent using mobile only, desktop only and both mobile and desktop together for each date. The query result format is in the following example:",
      "tables": [
        "Spending"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT aa.spend_date,\n       aa.platform,\n       COALESCE(bb.total_amount, 0) total_amount,\n       COALESCE(bb.total_users,0) total_users\nFROM\n    (SELECT DISTINCT(spend_date), a.platform   -- table aa\n    FROM Spending JOIN\n        (SELECT 'desktop' AS platform UNION\n        SELECT 'mobile' AS platform UNION\n        SELECT 'both' AS platform\n        ) a\n    ) aa\n    LEFT JOIN\n    (SELECT spend_date,                      -- table bb\n            platform,\n            SUM(amount) total_amount,\n            COUNT(user_id) total_users\n    FROM\n        (SELECT spend_date,\n                user_id,\n                (CASE COUNT(DISTINCT platform)\n                    WHEN 1 THEN platform\n                    WHEN 2 THEN 'both'\n                    END) platform,\n                SUM(amount) amount\n        FROM Spending\n        GROUP BY spend_date, user_id\n        ) b\n    GROUP BY spend_date, platform\n    ) bb\n    ON aa.platform = bb.platform AND\n    aa.spend_date = bb.spend_date"
        }
      ]
    },
    {
      "section_id": "1132-reported-posts-ii--medium---leetcode",
      "id": 1132,
      "title": "Reported Posts II",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/reported-posts-ii",
      "description": "Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places. The query result format is in the following example:",
      "tables": [
        "Actions",
        "Removals"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH t1 AS(\nSELECT a.action_date, (COUNT(DISTINCT r.post_id))/(COUNT(DISTINCT a.post_id)) AS result\nFROM (SELECT action_date, post_id\nFROM actions\nWHERE extra = 'spam' AND action = 'report') a\nLEFT JOIN\nremovals r\nON a.post_id = r.post_id\nGROUP BY a.action_date)\n\nSELECT ROUND(AVG(t1.result)*100,2) AS  average_daily_percent\nFROM t1"
        }
      ]
    },
    {
      "section_id": "1141-user-activity-for-the-past-30-days-i--easy---leetcode",
      "id": 1141,
      "title": "User Activity for the Past 30 Days I",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/user-activity-for-the-past-30-days-i",
      "description": "Write an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on some day if he/she made at least one activity on that day. The query result format is in the following example:",
      "tables": [
        "Activity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users\nFROM activity\nWHERE activity_date > '2019-06-26' AND activity_date < '2019-07-27'\nGROUP BY activity_date"
        }
      ]
    },
    {
      "section_id": "1142-user-activity-for-the-past-30-days-ii--easy---leetcode",
      "id": 1142,
      "title": "User Activity for the Past 30 Days II",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/user-activity-for-the-past-30-days-ii",
      "description": "Write an SQL query to find the average number of sessions per user for a period of 30 days ending 2019-07-27 inclusively, rounded to 2 decimal places. The sessions we want to count for a user are those with at least one activity in that time period. The query result format is in the following example:",
      "tables": [
        "Activity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT IFNULL(ROUND(AVG(a.num),2),0) AS average_sessions_per_user\nFROM (\nSELECT COUNT(DISTINCT session_id) AS num\nFROM activity\nWHERE activity_date BETWEEN '2019-06-28' AND '2019-07-27'\nGROUP BY user_id) a"
        }
      ]
    },
    {
      "section_id": "1148-article-views-i--easy---leetcode",
      "id": 1148,
      "title": "Article Views I",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/article-views-i",
      "description": "Write an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id. The query result format is in the following example:",
      "tables": [
        "Views"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT DISTINCT author_id AS id\nFROM Views\nWHERE author_id = viewer_id\nORDER BY author_id"
        }
      ]
    },
    {
      "section_id": "1149-article-views-ii--medium---leetcode",
      "id": 1149,
      "title": "Article Views II",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/article-views-ii",
      "description": "Write an SQL query to find all the people who viewed more than one article on the same date, sorted in ascending order by their id. The query result format is in the following example:",
      "tables": [
        "Views"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT DISTINCT viewer_id AS id#, COUNT(DISTINCT article_id) AS total\nFROM views\nGROUP BY viewer_id, view_date\nHAVING count(DISTINCT article_id)>1\nORDER BY 1"
        }
      ]
    },
    {
      "section_id": "1158-market-analysis-i--medium---leetcode",
      "id": 1158,
      "title": "Market Analysis I",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/market-analysis-i",
      "description": "Write an SQL query to find for each user, the join date and the number of orders they made as a buyer in 2019. The query result format is in the following example:",
      "tables": [
        "Users",
        "Orders",
        "Items"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT user_id AS buyer_id, join_date, coalesce(a.orders_in_2019,0)\nFROM users\nLEFT JOIN\n(\nSELECT buyer_id, coalesce(count(*), 0) AS orders_in_2019\nFROM orders o\nJOIN users u\nON u.user_id = o.buyer_id\nWHERE extract('year' FROM order_date) = 2019\nGROUP BY buyer_id) a\nON users.user_id = a.buyer_id"
        }
      ]
    },
    {
      "section_id": "1159-market-analysis-ii--hard---leetcode",
      "id": 1159,
      "title": "Market Analysis II",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/market-analysis-ii",
      "description": "Write an SQL query to find for each user, whether the brand of the second item (by date) they sold is their favorite brand. If a user sold less than two items, report the answer for that user as no. It is guaranteed that no seller sold more than one item on a day. The query result format is in the following example:",
      "tables": [
        "Users",
        "Orders",
        "Items"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT user_id AS seller_id,\n       IF(ISNULL(item_brand), \"no\", \"yes\") AS 2nd_item_fav_brand\nFROM Users LEFT JOIN\n(SELECT seller_id, item_brand\nFROM Orders INNER JOIN Items\nON Orders.item_id = Items.item_id\nWHERE (seller_id, order_date) IN\n(SELECT seller_id, MIN(order_date) AS order_date\n FROM Orders\n WHERE (seller_id, order_date) NOT IN\n (SELECT seller_id, MIN(order_date) FROM Orders GROUP BY seller_id)\nGROUP BY seller_id)\n ) AS t\nON Users.user_id = t.seller_id and favorite_brand = item_brand\n\n#Solution- 2:\nWITH t1 AS(\nSELECT user_id,\nCASE WHEN favorite_brand = item_brand THEN \"yes\"\nELSE \"no\"\nEND AS 2nd_item_fav_brand\nFROM users u LEFT JOIN\n(SELECT o.item_id, seller_id, item_brand, RANK() OVER(PARTITION BY seller_id ORDER BY order_date) AS rk\nFROM orders o join items i\nUSING (item_id)) a\nON u.user_id = a.seller_id\nWHERE a.rk = 2)\n\nSELECT u.user_id AS seller_id, COALESCE(2nd_item_fav_brand,\"no\") AS 2nd_item_fav_brand\nFROM users u LEFT JOIN t1\nUSING(user_id)"
        }
      ]
    },
    {
      "section_id": "1164-product-price-at-a-given-date--medium---leetcode",
      "id": 1164,
      "title": "Product Price at a Given Date",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/product-price-at-a-given-date",
      "description": "Write an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10. The query result format is in the following example:",
      "tables": [
        "Products"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nWITH t1 AS (\nSELECT a.product_id, new_price\nFROM(\nSELECT product_id, max(change_date) AS date\nFROM products\nWHERE change_date<='2019-08-16'\nGROUP BY product_id) a\nJOIN products p\nON a.product_id = p.product_id AND a.date = p.change_date),\n\nt2 AS (\nSELECT distinct product_id\n\tFROM products)\n\nSELECT t2.product_id, coalesce(new_price,10) AS price\nFROM t2 LEFT JOIN t1\nON t2.product_id = t1.product_id\nORDER BY price DESC\n\n#Solution- 2:\nSELECT t1.product_id AS product_id, IF(ISNULL(t2.price), 10, t2.price) AS price\nFROM\n  (SELECT distinct product_id\n  FROM Products) AS t1 LEFT JOIN\n  (SELECT product_id, new_price AS price\n   FROM Products\n   WHERE (product_id, change_date) in\n      (SELECT product_id, max(change_date)\n      FROM Products\n      WHERE change_date <='2019-08-16'\n      GROUP BY product_id)) AS t2\nON t1.product_id = t2.product_id"
        }
      ]
    },
    {
      "section_id": "1173-immediate-food-delivery-i--easy---leetcode",
      "id": 1173,
      "title": "Immediate Food Delivery I",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/immediate-food-delivery-i",
      "description": "If the preferred delivery date of the customer is the same as the order date then the order is called immediate otherwise it's called scheduled. Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places. The query result format is in the following example:",
      "tables": [
        "Delivery"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT\nROUND(SUM(CASE WHEN order_date=customer_pref_delivery_date THEN 1 ELSE 0 END)/count(1)*100, 2) immediate_percentage\nFROM Delivery;\n\n#Solution- 2:\nSELECT\nROUND(avg(CASE WHEN order_date=customer_pref_delivery_date THEN 1 ELSE 0 END)*100,2) AS immediate_percentage\nFROM delivery"
        }
      ]
    },
    {
      "section_id": "1174-immediate-food-delivery-ii--medium---leetcode",
      "id": 1174,
      "title": "Immediate Food Delivery II",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/immediate-food-delivery-ii",
      "description": "If the preferred delivery date of the customer is the same as the order date then the order is called immediate otherwise it's called scheduled. The first order of a customer is the order with the earliest order date that customer made. It is guaranteed that a customer has exactly one first order. Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places. The query result format is in the following example:",
      "tables": [
        "Delivery"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution- 1:\nSELECT ROUND(SUM(CASE WHEN order_date=customer_pref_delivery_date THEN 1 ELSE 0 END)/count(DISTINCT customer_id)*100, 2) immediate_percentage\nFROM Delivery\nWHERE (customer_id, order_date) IN\n    (SELECT customer_id, MIN(order_date)\n    FROM Delivery\n    GROUP BY customer_id)\n#Solution- 2:\nSELECT ROUND(AVG(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END)*100,2) as\nimmediate_percentage\nFROM\n(SELECT *,\n RANK() OVER(PARTITION BY customer_id ORDER BY order_date) AS rk\nFROM delivery) a\nWHERE a.rk=1"
        }
      ]
    },
    {
      "section_id": "1179-reformat-department-table--easy--leetcode",
      "id": 1179,
      "title": "Reformat Department Table",
      "difficulty": "Easy",
      "locked": false,
      "leetcode_url": "https://leetcode.com/problems/reformat-department-table/",
      "description": "Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month. The query result format is in the following example:",
      "tables": [
        "Department"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT id,\nSUM(IF(month='Jan', revenue, NULL)) AS Jan_Revenue,\nSUM(IF(month='Feb', revenue, NULL)) AS Feb_Revenue,\nSUM(IF(month='Mar', revenue, NULL)) AS Mar_Revenue,\nSUM(IF(month='Apr', revenue, NULL)) AS Apr_Revenue,\nSUM(IF(month='May', revenue, NULL)) AS May_Revenue,\nSUM(IF(month='Jun', revenue, NULL)) AS Jun_Revenue,\nSUM(IF(month='Jul', revenue, NULL)) AS Jul_Revenue,\nSUM(IF(month='Aug', revenue, NULL)) AS Aug_Revenue,\nSUM(IF(month='Sep', revenue, NULL)) AS Sep_Revenue,\nSUM(IF(month='Oct', revenue, NULL)) AS Oct_Revenue,\nSUM(IF(month='Nov', revenue, NULL)) AS Nov_Revenue,\nSUM(IF(month='Dec', revenue, NULL)) AS Dec_Revenue\nFROM Department\nGroup BY id;"
        }
      ]
    },
    {
      "section_id": "1193-monthly-transactions-i--medium---leetcode",
      "id": 1193,
      "title": "Monthly Transactions I",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/monthly-transactions-i",
      "description": "Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount. The query result format is in the following example:",
      "tables": [
        "Transactions"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH t1 AS(\nSELECT DATE_FORMAT(trans_date,'%Y-%m') AS month, country, COUNT(state) AS trans_count, sum(amount) AS trans_total_amount\nFROM transactions\nGROUP BY country, month(trans_date)),\n\nt2 AS (\nSELECT DATE_FORMAT(trans_date,'%Y-%m') AS month, country, COUNT(state) AS approved_count, sum(amount) AS approved_total_amount\nFROM transactions\nWHERE state = 'approved'\nGROUP BY country, month(trans_date))\n\nSELECT t1.month, t1.country, COALESCE(t1.trans_count,0) AS trans_count, COALESCE(t2.approved_count,0) AS approved_count, COALESCE(t1.trans_total_amount,0) AS trans_total_amount, COALESCE(t2.approved_total_amount,0) AS approved_total_amount\nFROM t1 LEFT JOIN t2\nON t1.country = t2.country and t1.month = t2.month"
        }
      ]
    },
    {
      "section_id": "1194-tournament-winners--hard---leetcode",
      "id": 1194,
      "title": "Tournament Winners",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/tournament-winners",
      "description": "The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins. Write an SQL query to find the winner in each group. The query result format is in the following example:",
      "tables": [
        "Players",
        "Matches"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH t1 AS(\nSELECT first_player, SUM(first_score) AS total\nFROM\n(SELECT first_player, first_score\nFROM matches\nUNION ALL\nSELECT second_player, second_score\nFROM matches) a\nGROUP BY 1),\n\nt2 AS(\nSELECT *, COALESCE(total,0) AS score\nFROM players p LEFT JOIN t1\nON p.player_id = t1.first_player)\n\nSELECT group_id, player_id\nFROM\n(SELECT *, ROW_NUMBER() OVER(PARTITION BY group_id ORDER BY group_id, score DESC) AS rn\nFROM t2) b\nWHERE b.rn = 1"
        }
      ]
    },
    {
      "section_id": "1204-last-person-to-fit-in-the-elevator--medium---leetcode",
      "id": 1204,
      "title": "Last Person to Fit in the Elevator",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/last-person-to-fit-in-the-elevator",
      "description": "The maximum weight the elevator can hold is 1000. Write an SQL query to find the person_name of the last person who will fit in the elevator without exceeding the weight limit. It is guaranteed that the person who is first in the queue can fit in the elevator. The query result format is in the following example:",
      "tables": [
        "Queue"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH t1 AS\n(\nSELECT *,\nSUM(weight) OVER(ORDER BY turn) AS cum_weight\nFROM queue\nORDER BY turn)\n\nSELECT t1.person_name\nFROM t1\nWHERE turn = (SELECT MAX(turn) FROM t1 WHERE t1.cum_weight<=1000)"
        }
      ]
    },
    {
      "section_id": "1205-monthly-transactions-ii--medium---leetcode",
      "id": 1205,
      "title": "Monthly Transactions II",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/monthly-transactions-ii",
      "description": "Write an SQL query to find for each month and country, the number of approved transactions and their total amount, the number of chargebacks and their total amount. Note: In your query, given the month and country, ignore rows with all zeros. The query result format is in the following example:",
      "tables": [
        "Transactions",
        "Chargebacks"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH t1 AS\n(SELECT country, extract('month' FROM trans_date), state, COUNT(*) AS approved_count, SUM(amount) AS approved_amount\nFROM transactions\nWHERE state = 'approved'\nGROUP BY 1, 2, 3),\nt2 AS(\nSELECT t.country, extract('month' FROM c.trans_date), SUM(amount) AS chargeback_amount, COUNT(*) AS chargeback_count\nFROM chargebacks c LEFT JOIN transactions t\nON trans_id = id\nGROUP BY t.country, extract('month' FROM c.trans_date)),\n\nt3 AS(\nSELECT t2.date_part, t2.country, COALESCE(approved_count,0) AS approved_count, COALESCE(approved_amount,0) AS approved_amount, COALESCE(chargeback_count,0) AS chargeback_count, COALESCE(chargeback_amount,0) AS chargeback_amount\nFROM t2 LEFT JOIN t1\nON t2.date_part = t1.date_part AND t2.country = t1.country),\n\nt4 AS(\nSELECT t1.date_part, t1.country, COALESCE(approved_count,0) AS approved_count, COALESCE(approved_amount,0) AS approved_amount, COALESCE(chargeback_count,0) AS chargeback_count, COALESCE(chargeback_amount,0) AS chargeback_amount\nFROM t2 RIGHT JOIN t1\nON t2.date_part = t1.date_part AND t2.country = t1.country)\n\nSELECT *\nFROM t3\nUNION\nSELECT *\nFROM t4\n\n#Solution 2:\nSELECT month, country,\n    SUM(CASE WHEN type='approved' THEN 1 ELSE 0 END) AS approved_count,\n    SUM(CASE WHEN type='approved' THEN amount ELSE 0 END) AS approved_amount,\n    SUM(CASE WHEN type='chargeback' THEN 1 ELSE 0 END) AS chargeback_count,\n    SUM(CASE WHEN type='chargeback' THEN amount ELSE 0 END) AS chargeback_amount\nFROM (\n    (\n    SELECT left(t.trans_date, 7) AS month, t.country, amount,'approved' AS type\n    FROM Transactions AS t\n    WHERE state='approved'\n    )\n    UNION ALL (\n    SELECT left(c.trans_date, 7) AS month, t.country, amount,'chargeback' AS type\n    FROM Transactions AS t JOIN Chargebacks AS c\n    ON t.id = c.trans_id\n    )\n) AS tt\nGROUP BY tt.month, tt.country\n\n#Solution 3:\nSELECT month, country,\n    SUM(CASE WHEN type='approved' THEN count ELSE 0 END) AS approved_count,\n    SUM(CASE WHEN type='approved' THEN amount ELSE 0 END) AS approved_amount,\n    SUM(CASE WHEN type='chargeback' THEN count ELSE 0 END) AS chargeback_count,\n    SUM(CASE WHEN type='chargeback' THEN amount ELSE 0 END) AS chargeback_amount\nFROM (\n    (\n    SELECT LEFT(t.trans_date, 7) AS month, t.country,\n    COUNT(1) AS count, SUM(amount) AS amount,'approved' AS type\n    FROM Transactions AS t LEFT JOIN Chargebacks AS c\n    ON t.id = c.trans_id\n    WHERE state='approved'\n    GROUP BY LEFT(t.trans_date, 7), t.country\n    )\n    union (\n    SELECT LEFT(c.trans_date, 7) AS month, t.country,\n        COUNT(1) AS count, SUM(amount) AS amount,'chargeback' AS type\n    FROM Transactions AS t JOIN Chargebacks AS c\n    ON t.id = c.trans_id\n    GROUP BY LEFT(c.trans_date, 7), t.country\n    )\n) AS tt\nGROUP BY tt.month, tt.country"
        }
      ]
    },
    {
      "section_id": "1211-queries-quality-and-percentage--easy---leetcode",
      "id": 1211,
      "title": "Queries Quality and Percentage",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/queries-quality-and-percentage",
      "description": "We define query quality as: We also define poor query percentage as: Write an SQL query to find each query_name, the quality and poor_query_percentage. Both quality and poor_query_percentage should be rounded to 2 decimal places. The query result format is in the following example:",
      "tables": [
        "Queries"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT query_name, ROUND(SUM(rating/position)/COUNT(*),2) AS quality,\nROUND(AVG(CASE WHEN rating<3 THEN 1 ELSE 0 END)*100,2) AS poor_query_percentage\nFROM queries\nGROUP BY query_name\n\n#Solution 2:\nSELECT query_name, ROUND(AVG(rating/position), 2) AS quality,\n       ROUND(100*SUM(CASE WHEN rating<3 THEN 1 ELSE 0 END)/COUNT(1), 2) AS poor_query_percentage\nFROM Queries\nGROUP BY query_name"
        }
      ]
    },
    {
      "section_id": "1212-team-scores-in-football-tournament--medium---leetcode",
      "id": 1212,
      "title": "Team Scores in Football Tournament",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/team-scores-in-football-tournament",
      "description": "You would like to compute the scores of all teams after all matches. Points are awarded as follows: A team receives three points if they win a match (Score strictly more goals than the opponent team). A team receives one point if they draw a match (Same number of goals as the opponent team). A team receives no points if they lose a match (Score less goals than the opponent team). Write an SQL query that selects the team_id, team_name and num_points of each team in the tournament after all described matches. Result table should be ordered by num_points (decreasing order). In case of a tie, order the records by team_id (increasing order). The query result format is in the following example:",
      "tables": [
        "Teams",
        "Matches"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT Teams.team_id, Teams.team_name,\n    SUM(CASE WHEN team_id=host_team AND host_goals>guest_goals THEN 3 ELSE 0 END) +\n    SUM(CASE WHEN team_id=host_team AND host_goals=guest_goals THEN 1 ELSE 0 END) +\n    SUM(CASE WHEN team_id=guest_team AND host_goals<guest_goals THEN 3 ELSE 0 END) +\n    SUM(CASE WHEN team_id=guest_team AND host_goals=guest_goals THEN 1 ELSE 0 END) AS num_points\nFROM Teams LEFT JOIN Matches\nON Teams.team_id = Matches.host_team OR Teams.team_id = Matches.guest_team\nGROUP BY Teams.team_id\nORDER BY num_points DESC, Teams.team_id ASC\n\n#Solution 2:\nSELECT Teams.team_id, Teams.team_name, SUM(if(isnull(num_points), 0, num_points)) AS num_points\nFROM Teams LEFT JOIN\n    (\n        SELECT host_team AS team_id,\n            SUM(CASE WHEN host_goals>guest_goals THEN 3\n                     WHEN host_goals=guest_goals THEN 1\n                     ELSE 0 END) AS num_points\n        FROM Matches\n        GROUP BY host_team\n        UNION ALL\n        SELECT guest_team AS team_id,\n            SUM(CASE WHEN host_goals<guest_goals THEN 3\n                     WHEN host_goals=guest_goals THEN 1\n                     ELSE 0 END) AS num_points\n        FROM Matches\n        GROUP BY guest_team\n    ) AS tt\nON Teams.team_id = tt.team_id\nGROUP BY Teams.team_id\nORDER BY num_points DESC, Teams.team_id ASC\n\n#Solution 3:\nSELECT Teams.team_id, Teams.team_name, IFNULL(SUM(num_points), 0) AS num_points\nFROM Teams LEFT JOIN\n    (\n        SELECT host_team AS team_id,\n            SUM(CASE WHEN host_goals>guest_goals THEN 3\n                     WHEN host_goals=guest_goals THEN 1\n                     ELSE 0 END) AS num_points\n        FROM Matches\n        GROUP BY host_team\n        UNION ALL\n        SELECT guest_team AS team_id,\n            SUM(CASE WHEN host_goals<guest_goals THEN 3\n                     WHEN host_goals=guest_goals THEN 1\n                     ELSE 0 END) AS num_points\n        FROM Matches\n        GROUP BY guest_team\n    ) AS tt\nON Teams.team_id = tt.team_id\nGROUP BY Teams.team_id\nORDER BY num_points DESC, Teams.team_id ASC\n\n#Solution 4:\nWITH t1 AS(\nSELECT c.host_id, c.host_name, c.host_points\nFROM(\nSELECT a.match_id, a.team_id AS host_id, a.team_name AS host_name, b.team_id AS guest_id, b.team_name AS guest_name, a.host_goals, a.guest_goals,\nCASE WHEN a.host_goals > a.guest_goals THEN 3\n     WHEN a.host_goals = a.guest_goals THEN 1\n     ELSE 0 END AS host_points,\nCASE WHEN a.host_goals < a.guest_goals THEN 3\n     WHEN a.host_goals = a.guest_goals THEN 1\n     ELSE 0 END AS guest_points\nFROM(\nSELECT *\nFROM matches m\nJOIN teams t\nON t.team_id = m.host_team) a\nJOIN\n(SELECT *\nFROM matches m\nJOIN teams t\nON t.team_id = m.guest_team) b\nON a.match_id = b.match_id) c\nUNION ALL\nSELECT d.guest_id, d.guest_name, d.guest_points\nFROM(\nSELECT a.match_id, a.team_id AS host_id, a.team_name AS host_name, b.team_id AS guest_id, b.team_name AS guest_name, a.host_goals, a.guest_goals,\nCASE WHEN a.host_goals > a.guest_goals THEN 3\n     WHEN a.host_goals = a.guest_goals THEN 1\n     ELSE 0 END AS host_points,\nCASE WHEN a.host_goals < a.guest_goals THEN 3\n     WHEN a.host_goals = a.guest_goals THEN 1\n     ELSE 0 END AS guest_points\nFROM(\nSELECT *\nFROM matches m\nJOIN teams t\nON t.team_id = m.host_team) a\nJOIN\n(SELECT *\nFROM matches m\nJOIN teams t\nON t.team_id = m.guest_team) b\nON a.match_id = b.match_id) d)\n\nSELECT team_id, team_name, coalesce(total,0) AS num_points\nFROM teams t2\nLEFT JOIN(\nSELECT host_id, host_name, SUM(host_points) AS total\nFROM t1\nGROUP BY host_id, host_name) e\nON t2.team_id = e.host_id\nORDER BY num_points DESC, team_id"
        }
      ]
    },
    {
      "section_id": "1225-report-contiguous-dates--hard---leetcode",
      "id": 1225,
      "title": "Report Contiguous Dates",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/report-contiguous-dates",
      "description": "A system is running one task every day. Every task is independent of the previous tasks. The tasks can fail or succeed. Write an SQL query to generate a report of period_state for each continuous interval of days in the period from 2019-01-01 to 2019-12-31. period_state is 'failed' if tasks in this interval failed or 'succeeded' if tasks in this interval succeeded. Interval of days are retrieved as start_date and end_date. Order result by start_date. The query result format is in the following example:",
      "tables": [
        "Failed",
        "Succeeded"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH t1 AS(\nSELECT MIN(success_date) AS start_date, MAX(success_date) AS end_date, state\nFROM(\nSELECT *, date_sub(success_date, interval ROW_NUMBER() OVER(ORDER BY success_date) day) AS diff, 1 AS state\nFROM succeeded\nWHERE success_date BETWEEN \"2019-01-01\" AND \"2019-12-31\") a\nGROUP BY diff),\n\nt2 AS(\nSELECT MIN(fail_date) AS start_date, MAX(fail_date) AS end_date, state\nFROM(\nSELECT *, date_sub(fail_date, interval ROW_NUMBER() OVER(ORDER BY fail_date) day) AS diff, 0 AS state\nFROM failed\nWHERE fail_date BETWEEN \"2019-01-01\" AND \"2019-12-31\") b\nGROUP BY diff)\n\nSELECT\nCASE WHEN c.state = 1 THEN \"succeeded\"\nELSE \"failed\"\nEND AS period_state,start_date, end_date\nFROM(\nSELECT *\nFROM t1\n\nUNION ALL\n\nSELECT *\nFROM t2) c\nORDER BY start_date\n\n#Solution 2:\n## First generate a list of dates\n##   succeeded 2019-01-01\n##   succeeded 2019-01-02\n##   ...\n##   failed 2019-01-04\n##   ...\n## Add group id for contiguous ranges\n## Notice: dates themselves are contiguous\n##\nSELECT period_state, MIN(date) AS start_date, MAX(date) AS end_date\nFROM (\n    SELECT period_state, date,\n         @rank := CASE WHEN @prev = period_state THEN @rank ELSE @rank+1 END AS rank,\n         @prev := period_state AS prev\n    FROM (\n        SELECT 'failed' AS period_state, fail_date AS date\n        FROM Failed\n        WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31'\n        UNION\n        SELECT 'succeeded' AS period_state, success_date AS date\n        FROM Succeeded\n        WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31') AS t,\n        (SELECT @rank:=0, @prev:='') AS rows\n    ORDER BY date ASC) AS tt\nGROUP BY rank\nORDER BY rank"
        }
      ]
    },
    {
      "section_id": "1241-number-of-comments-per-post--easy---leetcode",
      "id": 1241,
      "title": "Number of Comments per Post",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/number-of-comments-per-post",
      "description": "Write an SQL query to find number of comments per each post. Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order. Submissions may contain duplicate comments. You should count the number of unique comments per post. Submissions may contain duplicate posts. You should treat them as one post. The query result format is in the following example:",
      "tables": [
        "Submissions"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT a.sub_id AS post_id, coalesce(b.number_of_comments,0) AS number_of_comments\nFROM(\nSELECT DISTINCT sub_id FROM submissions WHERE parent_id IS NULL) a\nLEFT JOIN(\nSELECT parent_id, count(DISTINCT(sub_id)) AS number_of_comments\nFROM submissions\nGROUP BY parent_id\nHAVING parent_id = any(SELECT sub_id from submissions WHERE parent_id IS NULL)) b\nON a.sub_id = b.parent_id\nORDER BY post_id"
        }
      ]
    },
    {
      "section_id": "1251-average-selling-price--easy---leetcode",
      "id": 1251,
      "title": "Average Selling Price",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/average-selling-price",
      "description": "Write an SQL query to find the average selling price for each product. average_price should be rounded to 2 decimal places. The query result format is in the following example:",
      "tables": [
        "Prices",
        "UnitsSold"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT UnitsSold.product_id, ROUND(SUM(units*price)/SUM(units), 2) AS average_price\nFROM UnitsSold INNER JOIN Prices\nON UnitsSold.product_id = Prices.product_id\nAND UnitsSold.purchase_date BETWEEN Prices.start_date AND Prices.end_date\nGROUP BY UnitsSold.product_id"
        }
      ]
    },
    {
      "section_id": "1264-page-recommendations--medium---leetcode",
      "id": 1264,
      "title": "Page Recommendations",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/page-recommendations",
      "description": "Write an SQL query to recommend pages to the user with user_id = 1 using the pages that your friends liked. It should not recommend pages you already liked. Return result table in any order without duplicates. The query result format is in the following example:",
      "tables": [
        "Friendship",
        "Likes"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT DISTINCT page_id AS recommended_page\nFROM Likes\nWHERE user_id IN (SELECT user2_id\n    FROM Friendship\n    WHERE user1_id=1\n    UNION\n    SELECT user1_id\n    FROM Friendship\n    WHERE user2_id=1)\n    AND page_id NOT IN\n        (SELECT page_id\n        FROM Likes\n        WHERE user_id=1)"
        }
      ]
    },
    {
      "section_id": "1270-all-people-report-to-the-given-manager--medium---leetcode",
      "id": 1270,
      "title": "All People Report to the Given Manager",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/all-people-report-to-the-given-manager",
      "description": "Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company. The indirect relation between managers will not exceed 3 managers as the company is small. Return result table in any order without duplicates. The query result format is in the following example:",
      "tables": [
        "Employees"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\n## t3: directly report to employee_id 1\n## t2: directly report to t3\n## t1: directly report to t2\nSELECT t1.employee_id\nFROM Employees AS t1 INNER JOIN Employees AS t2\nON t1.manager_id = t2.employee_id\nJOIN Employees AS t3\nON t2.manager_id = t3.employee_id\nWHERE t3.manager_id = 1 AND t1.employee_id != 1\n\n#Solution 2:\nSELECT distinct employee_id\nFROM (\nSELECT employee_id\nFROM Employees\nWHERE manager_id IN\n(SELECT employee_id\nFROM Employees\nWHERE manager_id IN\n    (SELECT employee_id\n    FROM Employees\n    WHERE manager_id = 1))\nUNION\nSELECT employee_id\nFROM Employees\nWHERE manager_id IN\n    (SELECT employee_id\n    FROM Employees\n    WHERE manager_id = 1)\nUNION\nSELECT employee_id\n    FROM Employees\n    WHERE manager_id = 1) AS t\nWHERE employee_id != 1\n\n#Solution 3:\nSELECT employee_id\nFROM employees\nWHERE manager_id = 1 AND employee_id != 1\nUNION\nSELECT employee_id\nFROM employees\nWHERE manager_id = any (SELECT employee_id\nFROM employees\nWHERE manager_id = 1 AND employee_id != 1)\nUNION\nSELECT employee_id\nFROM employees\nWHERE manager_id = any (SELECT employee_id\nFROM employees\nWHERE manager_id = any (SELECT employee_id\nFROM employees\nWHERE manager_id = 1 AND employee_id != 1))"
        }
      ]
    },
    {
      "section_id": "1280-students-and-examinations-easy---leetcode",
      "id": 1280,
      "title": "Students and Examinations",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/students-and-examinations",
      "description": "Write an SQL query to find the number of times each student attended each exam. Order the result table by student_id and subject_name. The query result format is in the following example:",
      "tables": [
        "Students",
        "Subjects",
        "Examinations"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1: count with null\nSELECT Students.student_id, student_name, Subjects.subject_name, COUNT(Examinations.student_id) AS attended_exams\nFROM Students JOIN Subjects\nLEFT JOIN Examinations\nON Students.student_id = Examinations.student_id AND Subjects.subject_name = Examinations.subject_name\nGROUP BY Students.student_id, subject_name\n\n#Solution 2: using ISNULL\nSELECT Students.student_id, student_name, Subjects.subject_name, SUM(IF(ISNULL(Examinations.student_id), 0, 1)) AS attended_exams\nFROM Students JOIN Subjects\nLEFT JOIN Examinations\nON Students.student_id = Examinations.student_id AND Subjects.subject_name = Examinations.subject_name\nGROUP BY Students.student_id, subject_name\n\n#Solution 3: coalesce\nSELECT a.student_id AS student_id, a.student_name AS student_name, a.subject_name AS subject_name, coalesce(attended_exams,0) AS attended_exams\nFROM(\nSELECT *\nFROM students\nCROSS JOIN subjects\nGROUP BY student_id, student_name, subject_name) a\nLEFT JOIN\n(SELECT e.student_id, student_name, subject_name, COUNT(*) AS attended_exams\nFROM examinations e JOIN students s\nON e.student_id = s.student_id\nGROUP BY e.student_id, student_name, subject_name) b\nON a.student_id = b.student_id AND a.subject_name =b.subject_name\nORDER BY a.student_id ASC, a.subject_name ASC"
        }
      ]
    },
    {
      "section_id": "1285-find-the-start-and-end-number-of-continuous-ranges--medium---leetcode",
      "id": 1285,
      "title": "Find the Start and End Number of Continuous Ranges",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-the-start-and-end-number-of-continuous-ranges",
      "description": "Since some IDs have been removed from Logs. Write an SQL query to find the start and end number of continuous ranges in table Logs. Order the result table by start_id. The query result format is in the following example:",
      "tables": [
        "Logs"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT MIN(log_id) AS start_id, MAX(log_id) AS end_id\nFROM(\nSELECT log_id, log_id-ROW_NUMBER() OVER (ORDER BY log_id) AS rk\nFROM logs) a\nGROUP BY rk\n\n#Solution 2: Add temporary columns of rank and prev\nSELECT MIN(log_id) AS START_ID, MAX(log_id) AS END_ID\nFROM (SELECT log_id,\n        @rank := CASE WHEN @prev = log_id-1 THEN @rank ELSE @rank+1 END AS rank,\n        @prev := log_id AS prev\n    FROM Logs,\n       (SELECT @rank:=0, @prev:=-1) AS rows) AS tt\nGROUP BY rank\nORDER BY START_ID\n\n# Solution 3: Find the starting and ending sequences, then merge two AS one table\n## find the starting sequence: 1, 7, 10\n## find the ending sequence: 3, 8, 10\n## merge them AS one table\nSELECT start_id, MIN(end_id) AS end_id\nFROM (SELECT t1.log_id AS start_id\n    FROM logs AS t1 LEFT JOIN logs AS t2\n    ON t1.log_id-1 = t2.log_id\n    WHERE t2.log_id IS NULL) tt_start join\n    (SELECT t1.log_id AS end_id\n    FROM logs AS t1 LEFT JOIN logs AS t2\n    ON t1.log_id+1 = t2.log_id\n    WHERE t2.log_id IS NULL) tt_end\nWHERE start_id<=end_id\nGROUP BY start_id"
        }
      ]
    },
    {
      "section_id": "1294-weather-type-in-each-country--easy---leetcode",
      "id": 1294,
      "title": "Weather Type in Each Country",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/weather-type-in-each-country",
      "description": "Write an SQL query to find the type of weather in each country for November 2019. The type of weather is Cold if the average weather_state is less than or equal 15, Hot if the average weather_state is greater than or equal 25 and Warm otherwise. Return result table in any order. The query result format is in the following example:",
      "tables": [
        "Countries",
        "Weather"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT country_name, CASE WHEN AVG(weather_state) <= 15 THEN \"Cold\"\n                          WHEN AVG(weather_state) >= 25 THEN \"Hot\"\n                          ELSE \"Warm\" END AS weather_type\nFROM Countries INNER JOIN Weather\nON Countries.country_id = Weather.country_id\nWHERE MONTH(day) = 11\nGORUP BY country_name"
        }
      ]
    },
    {
      "section_id": "1303-find-the-team-size--easy---leetcode",
      "id": 1303,
      "title": "Find the Team Size",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-the-team-size",
      "description": "Write an SQL query to find the team size of each of the employees. Return result table in any order. The query result format is in the following example:",
      "tables": [
        "Employee"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT employee_id, b.team_size\nFROM employee e\nJOIN\n(\nSELECT team_id, count(team_id) AS team_size\nFROM employee\nGROUP BY team_id) b\nON e.team_id = b.team_id"
        }
      ]
    },
    {
      "section_id": "1308-running-total-for-different-genders--medium---leetcode",
      "id": 1308,
      "title": "Running Total for Different Genders",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/running-total-for-different-genders",
      "description": "Write an SQL query to find the total score for each gender at each day. Order the result table by gender and day The query result format is in the following example:",
      "tables": [
        "Scores"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT gender, day,\nSUM(score_points) OVER(PARTITION BY gender ORDER BY day) AS total\nFROM scores\nGROUP BY 1,2\nORDER BY 1,2\n\n#Solution 2:\nSELECT t1.gender, t1.day, SUM(t2.score_points) AS total\nFROM Scores AS t1 JOIN Scores AS t2\nON t1.gender = t2.gender\nAND t1.day>=t2.day\nGROUP BY t1.gender, t1.day"
        }
      ]
    },
    {
      "section_id": "1321-restaurant-growth--medium---leetcode",
      "id": 1321,
      "title": "Restaurant Growth",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/restaurant-growth",
      "description": "You are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day). Write an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before) . The query result format is in the following example: Return result table ordered by visited_on. average_amount should be rounded to 2 decimal places, all dates are in the format ('YYYY-MM-DD').",
      "tables": [
        "Customer"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT visited_on, SUM(amount) OVER(ORDER BY visited_on ROWS 6 PRECEDING),\nround(avg(amount) OVER(ORDER BY visited_on ROWS 6 PRECEDING),2)\nFROM\n(\n\tSELECT visited_on, SUM(amount) AS amount\n\tFROM customer\n\tGROUP BY visited_on\n\tORDER BY visited_on\n) a\nORDER BY visited_on offset 6 ROWS\n\n#Solution 2:\nSELECT t1.visited_on,\n    SUM(t2.amount) AS amount,\n    round(avg(t2.amount), 2) AS average_amount\nFROM (\n    SELECT visited_on, SUM(amount) AS amount\n    FROM Customer\n    GROUP BY visited_on) AS t1\n    inner join\n     (\n    SELECT visited_on, SUM(amount) AS amount\n    FROM Customer\n    GROUP BY visited_on) AS t2\nON t2.visited_on BETWEEN DATE_SUB(t1.visited_on, INTERVAL 6 DAY) and t1.visited_on\nGROUP BY t1.visited_on\nHAVING COUNT(1)=7"
        }
      ]
    },
    {
      "section_id": "1322-ads-performance--easy---leetcode",
      "id": 1322,
      "title": "Ads Performance",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/ads-performance",
      "description": "A company is running Ads and wants to calculate the performance of each Ad. Performance of the Ad is measured using Click-Through Rate (CTR) where: Write an SQL query to find the ctr of each Ad. Round ctr to 2 decimal points. Order the result table by ctr in descending order and by ad_id in ascending order in case of a tie. The query result format is in the following example:",
      "tables": [
        "Ads"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT ad_id,\n    (CASE WHEN clicks+views = 0 THEN 0 ELSE ROUND(clicks/(clicks+views)*100, 2) END) AS ctr\nFROM\n    (SELECT ad_id,\n        SUM(CASE WHEN action='Clicked' THEN 1 ELSE 0 END) AS clicks,\n        SUM(CASE WHEN action='Viewed' THEN 1 ELSE 0 END) AS views\n    FROM Ads\n    GROUP BY ad_id) AS t\nORDER BY ctr DESC, ad_id ASC\n\n#Solution 2:\nWITH t1 AS(\nSELECT ad_id, SUM(CASE WHEN action in ('Clicked') THEN 1 ELSE 0 END) AS clicked\nFROM ads\nGROUP BY ad_id\n)\n\n, t2 AS\n(\nSELECT ad_id AS ad, SUM(CASE WHEN action in ('Clicked','Viewed') THEN 1 ELSE 0 END) AS total\nFROM ads\nGROUP BY ad_id\n)\n\nSELECT a.ad_id, coalesce(round((clicked +0.0)/nullif((total +0.0),0)*100,2),0) AS ctr\nFROM\n(\nselect *\nFROM t1 JOIN t2\nON t1.ad_id = t2.ad) a\nORDER BY ctr DESC, ad_id"
        }
      ]
    },
    {
      "section_id": "1327-list-the-products-ordered-in-a-period--easy---leetcode",
      "id": 1327,
      "title": "List the Products Ordered in a Period",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/list-the-products-ordered-in-a-period",
      "description": "Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount. Return result table in any order. The query result format is in the following example:",
      "tables": [
        "Products",
        "Orders"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT a.product_name, a.unit\nFROM\n(SELECT p.product_name, SUM(unit) AS unit\nFROM orders o\nJOIN products p\nON o.product_id = p.product_id\nWHERE MONTH(order_date)=2 and YEAR(order_date) = 2020\nGROUP BY o.product_id) a\nWHERE a.unit>=100\n\n#Solution 2:\nSELECT product_name, SUM(unit) AS unit\nFROM Products JOIN Orders\nON Products.product_id = Orders.product_id\nWHERE left(order_date, 7) = \"2020-02\"\nGROUP BY Products.product_id\nHAVING SUM(unit)>=100"
        }
      ]
    },
    {
      "section_id": "1336-number-of-transactions-per-visit--hard---leetcode",
      "id": 1336,
      "title": "Number of Transactions per Visit",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/number-of-transactions-per-visit",
      "description": "A bank wants to draw a chart of the number of transactions bank visitors did in one visit to the bank and the corresponding number of visitors who have done this number of transaction in one visit. Write an SQL query to find how many users visited the bank and didn't do any transactions, how many visited the bank and did one transaction and so on. The result table will contain two columns: Order the result table by transactions_count. The query result format is in the following example: The chart drawn for this example is as follows:",
      "tables": [
        "Visits",
        "Transactions"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH RECURSIVE t1 AS(\n                    SELECT visit_date,\n                           COALESCE(num_visits,0) as num_visits,\n                           COALESCE(num_trans,0) as num_trans\n                    FROM ((\n                          SELECT visit_date, user_id, COUNT(*) as num_visits\n                          FROM visits\n                          GROUP BY 1, 2) AS a\n                         LEFT JOIN\n                          (\n                           SELECT transaction_date,\n                                 user_id,\n                                 count(*) as num_trans\n                            FROM transactions\n                          GROUP BY 1, 2) AS b\n                         ON a.visit_date = b.transaction_date and a.user_id = b.user_id)\n                      ),\n\n              t2 AS (\n                      SELECT MAX(num_trans) as trans\n                        FROM t1\n                      UNION ALL\n                      SELECT trans-1\n                        FROM t2\n                      WHERE trans >= 1)\n\nSELECT trans as transactions_count,\n       COALESCE(visits_count,0) as visits_count\n  FROM t2 LEFT JOIN (\n                    SELECT num_trans as transactions_count, COALESCE(COUNT(*),0) as visits_count\n                    FROM t1\n                    GROUP BY 1\n                    ORDER BY 1) AS a\nON a.transactions_count = t2.trans\nORDER BY 1"
        }
      ]
    },
    {
      "section_id": "1341-movie-rating--medium---leetcode",
      "id": 1341,
      "title": "Movie Rating",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/movie-rating",
      "description": "Write the following SQL query: Find the name of the user who has rated the greatest number of the movies. In case of a tie, return lexicographically smaller user name. Find the movie name with the highest average rating in February 2020. In case of a tie, return lexicographically smaller movie name.. Query is returned in 2 rows, the query result format is in the following example:",
      "tables": [
        "Movies",
        "Users",
        "Movie_Rating"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\n(SELECT name AS results\nFROM Movie_Rating JOIN Users\nON Movie_Rating.user_id = Users.user_id\nGROUP BY Movie_Rating.user_id\nORDER BY count(1) DESC, name\nLIMIT 1)\nUNION ALL\n(SELECT title AS results\nFROM Movie_Rating JOIN Movies\nON Movie_Rating.movie_id = Movies.movie_id\nWHERE left(created_at, 7) = \"2020-02\"\nGROUP BY Movie_Rating.movie_id\nORDER BY avg(rating) DESC, title\nLIMIT 1\n)\n\n#Solution 2:\nSELECT name AS results\nFROM(\n(SELECT a.name\nFROM(\nSELECT name, count(*),\nrank() OVER(ORDER BY count(*) DESC) AS rk\nFROM movie_rating m\nJOIN users u\nON m.user_id = u.user_id\nGROUP BY name, m.user_id\nORDER BY rk, name) a\nLIMIT 1)\nUNION\n(SELECT title\nFROM(\nSELECT title, round(avg(rating),1) AS rnd\nFROM movie_rating m\nJOIN movies u\non m.movie_id = u.movie_id\nWHERE month(created_at) = 2\nGROUP BY title\nORDER BY rnd DESC, title) b\nLIMIT 1)) AS d"
        }
      ]
    },
    {
      "section_id": "1350-students-with-invalid-departments--easy---leetcode",
      "id": 1350,
      "title": "Students With Invalid Departments",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/students-with-invalid-departments",
      "description": "Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Departments",
        "Students"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT s.id, s.name\nFROM students s LEFT JOIN\ndepartments d\nON s.department_id = d.id\nWHERE d.name IS NULL;\n\n#Solution 2:\nSELECT id, name\nFROM Students\nWHERE department_id NOT IN\n    (SELECT id FROM Departments)"
        }
      ]
    },
    {
      "section_id": "1355-activity-participants--medium---leetcode",
      "id": 1355,
      "title": "Activity Participants",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/activity-participants",
      "description": "Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants. Return the result table in any order. Each activity in table Activities is performed by any person in the table Friends. The query result format is in the following example:",
      "tables": [
        "Friends",
        "Activities"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH CTE AS\n(SELECT COUNT(*) AS cnt, activity FROM Friends GROUP BY activity)\n\nSELECT activity FROM CTE\nWHERE cnt NOT IN\n    (SELECT MAX(cnt) FROM CTE\n    UNION ALL\n    SELECT MIN(cnt) FROM CTE)\n\n#Solution 2:\nWITH t1 AS(\nSELECT MAX(a.total) AS total\nFROM(\n    SELECT activity, COUNT(*) AS total\n    FROM friends\n    GROUP BY activity) a\n\tUNION ALL\n\tSELECT MIN(b.total) AS low\n    FROM(\n    SELECT activity, COUNT(*) AS total\n    FROM friends\n    GROUP BY activity) b),\nt2 AS\n(\n    SELECT activity, COUNT(*) AS total\n    FROM friends\n    GROUP BY activity\n)\n\nSELECT activity\nFROM t1 RIGHT JOIN t2\nON t1.total = t2.total\nWHERE t1.total is null"
        }
      ]
    },
    {
      "section_id": "1364-number-of-trusted-contacts-of-a-customer--medium---leetcode",
      "id": 1364,
      "title": "Number of Trusted Contacts of a Customer",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/number-of-trusted-contacts-of-a-customer",
      "description": "Write an SQL query to find the following for each invoice_id: The query result format is in the following example:",
      "tables": [
        "Customers",
        "Contacts",
        "Invoices"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT invoice_id, customer_name, price,\n COUNT(Contacts.user_id) AS contacts_cnt,\n SUM(CASE WHEN Contacts.contact_name IN\n    (SELECT customer_name FROM Customers)\n    THEN 1 ELSE 0 END) AS trusted_contacts_cnt\nFROM Invoices INNER JOIN Customers ON Invoices.user_id = Customers.customer_id\nLEFT JOIN Contacts ON Customers.customer_id = Contacts.user_id\nGROUP BY Invoices.invoice_id, customer_name\nORDER BY Invoices.invoice_id"
        }
      ]
    },
    {
      "section_id": "1369-get-the-second-most-recent-activity--hard---leetcode",
      "id": 1369,
      "title": "Get the Second Most Recent Activity",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/get-the-second-most-recent-activity",
      "description": "Write an SQL query to show the second most recent activity of each user. If the user only has one activity, return that one. A user can't perform more than one activity at the same time. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "UserActivity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "(SELECT *\nFROM UserActivity\nGROUP BY username\nHAVING count(1) = 1)\nUNION\n(SELECT a.*\nFROM UserActivity AS a LEFT JOIN UserActivity AS b\non a.username = b.username AND a.endDate<b.endDate\nGROUP BY a.username, a.endDate\nHAVING count(b.endDate) = 1)"
        }
      ]
    },
    {
      "section_id": "1378-replace-employee-id-with-the-unique-identifier--easy---leetcode",
      "id": 1378,
      "title": "Replace Employee ID With The Unique Identifier",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier",
      "description": "Write an SQL query to show the unique ID of each user, If a user doesn't have a unique ID replace just show null. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Employees",
        "EmployeeUNI"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT unique_id, name\nFROM Employees\nLEFT JOIN EmployeeUNI\nON Employees.id = EmployeeUNI.id"
        }
      ]
    },
    {
      "section_id": "1384-total-sales-amount-by-year--hard---leetcode",
      "id": 1384,
      "title": "Total Sales Amount by Year",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/total-sales-amount-by-year",
      "description": "+---------------+---------+ | Column Name | Type | +---------------+---------+ | product_id | int | | product_name | varchar | +---------------+---------+ product_id is the primary key for this table. product_name is the name of the product. Write an SQL query to report the Total sales amount of each item for each year, with corresponding product name, product_id, product_name and report_year. Dates of the sales years are between 2018 to 2020. Return the result table ordered by product_id and report_year. The query result format is in the following example:",
      "tables": [
        "Product",
        "Sales"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT\n    b.product_id,\n    a.product_name,\n    a.yr AS report_year,\n    CASE\n        WHEN YEAR(b.period_start)=YEAR(b.period_end) AND a.yr=YEAR(b.period_start) THEN DATEDIFF(b.period_end,b.period_start)+1\n        WHEN a.yr=YEAR(b.period_start) THEN DATEDIFF(DATE_FORMAT(b.period_start,'%Y-12-31'),b.period_start)+1\n        WHEN a.yr=YEAR(b.period_end) THEN DAYOFYEAR(b.period_end)\n        WHEN a.yr>YEAR(b.period_start) AND a.yr<YEAR(b.period_end) THEN 365\n        ELSE 0\n    END * average_daily_sales AS total_amount\nFROM\n    (SELECT product_id,product_name,'2018' AS yr FROM Product\n    UNION\n    SELECT product_id,product_name,'2019' AS yr FROM Product\n    UNION\n    SELECT product_id,product_name,'2020' AS yr FROM Product) a\n    JOIN\n    Sales b\n    ON a.product_id=b.product_id\nHAVING total_amount > 0\nORDER BY b.product_id,a.yr"
        }
      ]
    },
    {
      "section_id": "1393-capital-gainloss--medium---leetcode",
      "id": 1393,
      "title": "Capital Gain/Loss",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/capital-gainloss",
      "description": "Write an SQL query to report the Capital gain/loss for each stock. The capital gain/loss of a stock is total gain or loss after buying and selling the stock one or many times. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Stocks"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT stock_name,\n       SUM(CASE WHEN operation = 'Buy' THEN -price ELSE price END) AS capital_gain_loss\nFROM Stocks\nGROUP BY stock_name;\n\n#Solution 2:\nSELECT stock_name, (one-two) AS capital_gain_loss\nFROM(\n(SELECT stock_name, sum(price) AS one\nFROM stocks\nWHERE operation = 'Sell'\nGROUP BY stock_name) b\nLEFT JOIN\n(SELECT stock_name AS name, sum(price) AS two\nFROM stocks\nWHERE operation = 'Buy'\nGROUP BY stock_name) c\nON b.stock_name = c.name)\nORDER BY capital_gain_loss DESC;"
        }
      ]
    },
    {
      "section_id": "1398-customers-who-bought-products-a-and-b-but-not-c--medium---leetcode",
      "id": 1398,
      "title": "Customers Who Bought Products A and B but Not C",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/customers-who-bought-products-a-and-b-but-not-c",
      "description": "Write an SQL query to report the customer_id and customer_name of customers who bought products \"A\", \"B\" but did not buy the product \"C\" since we want to recommend them buy this product. Return the result table ordered by customer_id. The query result format is in the following example.",
      "tables": [
        "Customers",
        "Orders"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH t1 AS\n(\nSELECT customer_id\nFROM orders\nWHERE product_name = 'B' AND\ncustomer_id IN (SELECT customer_id\nFROM orders\nWHERE product_name = 'A'))\n\nSELECT t1.customer_id, c.customer_name\nFROM t1 JOIN customers c\nON t1.customer_id = c.customer_id\nWHERE t1.customer_id != all(SELECT customer_id\nFROM orders\nWHERE product_name = 'C')\n\n#Solution 2:\nSELECT *\nFROM Customers\nWHERE customer_id IN\n    (SELECT DISTINCT customer_id\n     FROM Orders\n     WHERE product_name = 'A'\n    ) AND\n    customer_id IN\n    (SELECT DISTINCT customer_id\n     FROM Orders\n     WHERE product_name = 'B'\n    ) AND\n    customer_id NOT IN\n    (SELECT DISTINCT customer_id\n     FROM Orders\n     WHERE product_name = 'C'\n    )\nORDER BY customer_id\n\n#Solution 3:\nSELECT Customers.*\nFROM (\n    SELECT customer_id,\n     sum(CASE WHEN product_name = 'A' THEN 1 ELSE 0 END) AS product_a,\n     sum(CASE WHEN product_name = 'B' THEN 1 ELSE 0 END) AS product_b\n    FROM Orders\n    GROUP BY customer_id) AS t JOIN Customers\nON t.customer_id = Customers.customer_id\nWHERE t.product_a>0 AND product_b >0 AND Customers.customer_id NOT IN (\n    SELECT DISTINCT customer_id\n    FROM Orders\n    WHERE product_name = 'C')\nORDER BY Customers.customer_id"
        }
      ]
    },
    {
      "section_id": "1407-top-travellers--easy---leetcode",
      "id": 1407,
      "title": "Top Travellers",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/top-travellers",
      "description": "Write an SQL query to report the distance travelled by each user. Return the result table ordered by travelled_distance in descending order, if two or more users travelled the same distance, order them by their name in ascending order. The query result format is in the following example.",
      "tables": [
        "Users",
        "Rides"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT U.name AS name, COALESCE(SUM(R.distance),0) AS travelled_distance\nFROM Users U LEFT JOIN Rides R\nON R.user_id = U.id\nGROUP BY name\nORDER BY travelled_distance DESC, name\n\n#Solution 2:\nSELECT name, IFNULL(SUM(distance), 0) AS travelled_distance\nFROM Users LEFT JOIN Rides\nON Users.id = Rides.user_id\nGROUP BY Users.id\nORDER BY travelled_distance DESC, name\n\n#Solution 3:\nSELECT name, SUM(IF(ISNULL(distance), 0, distance)) AS travelled_distance\nFROM Users LEFT JOIN Rides\nON Users.id = Rides.user_id\nGROUP BY Users.id\nORDER BY travelled_distance DESC, name"
        }
      ]
    },
    {
      "section_id": "1412-find-the-quiet-students-in-all-exams--hard---leetcode",
      "id": 1412,
      "title": "Find the Quiet Students in All Exams",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-the-quiet-students-in-all-exams",
      "description": "A \"quite\" student is the one who took at least one exam and didn't score neither the high score nor the low score. Write an SQL query to report the students (student_id, student_name) being \"quiet\" in ALL exams. Don't return the student who has never taken any exam. Return the result table ordered by student_id. The query result format is in the following example.",
      "tables": [
        "Student",
        "Exam"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH t1 AS(\nSELECT student_id\nFROM\n(SELECT *,\nMIN(score) OVER(PARTITION BY exam_id) AS least,\nMAX(score) OVER(PARTITION BY exam_id) AS most\nFROM exam) a\nWHERE least = score OR most = score)\n\nSELECT DISTINCT student_id, student_name\nFROM exam JOIN student\nUSING (student_id)\nWHERE student_id != all(SELECT student_id FROM t1)\norder by 1\n\n#Solution 2:\nSELECT DISTINCT Student.*\nFROM Student INNER JOIN Exam\nON Student.student_id = Exam.student_id\nWHERE student.student_id NOT IN\n    (SELECT e1.student_id\n    FROM Exam AS e1 INNER JOIN\n        (SELECT exam_id, MIN(score) AS min_score, MAX(score) AS max_score\n        FROM Exam\n        GROUP BY exam_id) AS e2\n    ON e1.exam_id = e2.exam_id\n    WHERE e1.score = e2.min_score OR e1.score = e2.max_score)\nORDER BY student_id"
        }
      ]
    },
    {
      "section_id": "1421-npv-queries--medium---leetcode",
      "id": 1421,
      "title": "NPV Queries",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/npv-queries",
      "description": "Write an SQL query to find the npv of all each query of queries table. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "NPV",
        "Queries"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT q.id, q.year, COALESCE(n.npv,0) AS npv\nFROM queries q\nLEFT JOIN npv n\nON q.id = n.id AND q.year=n.year\n\n#Solution 2:\nSELECT Queries.*, IF(ISNULL(npv), 0, npv) AS npv\nFROM Queries LEFT JOIN NPV\nON Queries.id = NPV.id AND Queries.year = NPV.year"
        }
      ]
    },
    {
      "section_id": "1435-create-a-session-bar-chart--easy---leetcode",
      "id": 1435,
      "title": "Create a Session Bar Chart",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/create-a-session-bar-chart",
      "description": "You want to know how long a user visits your application. You decided to create bins of \"[0-5>\", \"[5-10>\", \"[10-15>\" and \"15 minutes or more\" and count the number of sessions on it. Write an SQL query to report the (bin, total) in any order.",
      "tables": [
        "Sessions"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\n(SELECT '[0-5>' AS bin,\n SUM(CASE WHEN duration/60 < 5 THEN 1 ELSE 0 END) AS total FROM Sessions)\n UNION\n(SELECT '[5-10>' AS bin,\n SUM(CASE WHEN ((duration/60 >= 5) AND (duration/60 < 10)) THEN 1 ELSE 0 END) AS total FROM Sessions)\n UNION\n(SELECT '[10-15>' AS bin,\n SUM(CASE WHEN ((duration/60 >= 10) AND (duration/60 < 15)) THEN 1 ELSE 0 END) AS total FROM Sessions)\n UNION\n(SELECT '15 or more' AS bin,\n SUM(CASE WHEN duration/60 >= 15 THEN 1 ELSE 0 END) AS total FROM Sessions)\n\n#Solution 2:\nSELECT '[0-5>' AS bin, count(1) AS total\nFROM Sessions\nWHERE duration>=0 AND duration < 300\nUNION\nSELECT '[5-10>' AS bin, count(1) AS total\nFROM Sessions\nWHERE duration>=300 AND duration < 600\nUNION\nSELECT '[10-15>' AS bin, count(1) AS total\nFROM Sessions\nWHERE duration>=600 AND duration < 900\nUNION\nSELECT '15 or more' AS bin, count(1) AS total\nFROM Sessions\nWHERE duration >= 900"
        }
      ]
    },
    {
      "section_id": "1440-evaluate-boolean-expression--medium---leetcode",
      "id": 1440,
      "title": "Evaluate Boolean Expression",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/evaluate-boolean-expression",
      "description": "Table Variables: Table Expressions: Write an SQL query to evaluate the boolean expressions in Expressions table. Return the result table in any order. The query result format is in the following example.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH t1 AS(\nSELECT e.left_operand, e.operator, e.right_operand, v.value AS left_val, v_1.value AS right_val\nFROM expressions e\nJOIN variables v\nON v.name = e.left_operand\nJOIN variables v_1\nON v_1.name = e.right_operand)\n\nSELECT t1.left_operand, t1.operator, t1.right_operand,\nCASE WHEN t1.operator = '<' THEN (SELECT t1.left_val< t1.right_val)\nWHEN t1.operator = '>' THEN (SELECT t1.left_val > t1.right_val)\nWHEN t1.operator = '=' THEN (SELECT t1.left_val = t1.right_val)\nELSE FALSE\nEND AS VALUE\nFROM t1\n\n#Solution 2:\n# nested INNER JOIN can trim the volume of the intermediate table, which gives us better performance\nSELECT t.left_operand, t.operator, t.right_operand,\n    (CASE WHEN v1_value>v2.value AND operator = '>' THEN \"true\"\n          WHEN v1_value<v2.value AND operator = '<' THEN \"true\"\n          WHEN v1_value=v2.value AND operator = '=' THEN \"true\"\n          ELSE \"false\"\n          END) AS value\nFROM\n   (SELECT e.*, v1.value AS v1_value\n    FROM Expressions AS e INNER JOIN Variables AS v1\n    ON e.left_operand = v1.name) AS t INNER JOIN Variables AS v2\n    ON t.right_operand = v2.name\n\n#Solution 3:\nSELECT t.left_operand, t.operator, t.right_operand,\n    (CASE WHEN operator = '>' THEN IF(v1_value>v2.value, \"true\", \"false\")\n          WHEN operator = '<' THEN IF(v1_value<v2.value, \"true\", \"false\")\n          WHEN operator = '=' THEN IF(v1_value=v2.value, \"true\", \"false\")\n          END) AS value\nFROM\n   (SELECT e.*, v1.value AS v1_value\n    FROM Expressions AS e INNER JOIN Variables AS v1\n    ON e.left_operand = v1.name) AS t INNER JOIN Variables AS v2\n    ON t.right_operand = v2.name"
        }
      ]
    },
    {
      "section_id": "1445-apples--oranges--medium---leetcode",
      "id": 1445,
      "title": "Apples & Oranges",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/apples-oranges",
      "description": "Write an SQL query to report the difference between number of apples and oranges sold each day. Return the result table ordered by sale_date in format ('YYYY-MM-DD'). The query result format is in the following example:",
      "tables": [
        "Sales"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT sale_date, sum(CASE WHEN fruit='apples' THEN sold_num ELSE -sold_num END) AS diff\nFROM Sales\nGROUP BY sale_date\n\n#Solution 2:\nSELECT sale_date, sold_num-sold AS diff\nFROM\n((SELECT *\nFROM sales\nWHERE fruit = 'apples') a\nJOIN\n(SELECT sale_date AS sale, fruit, sold_num AS sold\nFROM sales\nWHERE fruit = 'oranges') b\nON a.sale_date = b.sale)"
        }
      ]
    },
    {
      "section_id": "1454-active-users--medium---leetcode",
      "id": 1454,
      "title": "Active Users",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/active-users",
      "description": "Table Accounts: Table Logins: Write an SQL query to find the id and the name of active users. Active users are those who logged in to their accounts for 5 or more consecutive days. Return the result table ordered by the id. The query result format is in the following example: Follow up question: Can you write a general solution if the active users are those who logged in to their accounts for n or more consecutive days?",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH t1 AS (\nSELECT id,login_date,\nlead(login_date,4) OVER(PARTITION BY id ORDER BY login_date) date_5\nFROM (SELECT DISTINCT * FROM Logins) b\n)\n\nSELECT DISTINCT a.id, a.name FROM t1\nINNER JOIN accounts a\nON t1.id = a.id\nWHERE DATEDIFF(t1.date_5,login_date) = 4\nORDER BY id\n\n#Soltion 2:\nSELECT *\nFROM Accounts\nWHERE id IN\n    (SELECT DISTINCT t1.id\n    FROM Logins AS t1 INNER JOIN Logins AS t2\n    ON t1.id = t2.id AND datediff(t1.login_date, t2.login_date) BETWEEN 1 AND 4\n    GROUP BY t1.id, t1.login_date\n    HAVING count(DISTINCT(t2.login_date)) = 4)\nORDER BY id"
        }
      ]
    },
    {
      "section_id": "1459-rectangles-area--medium---leetcode",
      "id": 1459,
      "title": "Rectangles Area",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/rectangles-area",
      "description": "Write an SQL query to report of all possible rectangles which can be formed by any two points of the table. Each row in the result contains three columns (p1, p2, area) where:",
      "tables": [
        "Points"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT t1.id AS p1, t2.id AS p2, ABS(t1.x_value-t2.x_value)*ABS(t1.y_value-t2.y_value) AS area\nFROM Points AS t1 INNER JOIN Points AS t2\nON t1.id < t2.id\nAND t1.x_value != t2.x_value AND t1.y_value != t2.y_value\nORDER BY area DESC, p1, p2"
        }
      ]
    },
    {
      "section_id": "1468-calculate-salaries--medium---leetcode",
      "id": 1468,
      "title": "Calculate Salaries",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/calculate-salaries",
      "description": "Table Salaries: Write an SQL query to find the salaries of the employees after applying taxes. The tax rate is calculated for each company based on the following criteria: The query result format is in the following example:",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nWITH t1 AS (\nSELECT company_id, employee_id, employee_name, salary AS sa, MAX(salary) OVER(PARTITION BY company_id) AS maximum\nFROM salaries)\n\nSELECT company_id, employee_id, employee_name,\nCASE WHEN t1.maximum<1000 THEN t1.sa\nWHEN t1.maximum BETWEEN 1000 AND 10000 THEN ROUND(t1.sa*.76,0)\nELSE ROUND(t1.sa*.51,0)\nEND AS salary\nFROM t1\n\n#Soltion 2:\nSELECT Salaries.company_id, Salaries.employee_id, Salaries.employee_name,\n    ROUND(CASE WHEN salary_max<1000 THEN Salaries.salary\n               WHEN salary_max>=1000 AND salary_max<=10000 THEN Salaries.salary * 0.76\n               ELSE Salaries.salary * 0.51 END, 0) AS salary\nFROM Salaries INNER JOIN (\n    SELECT company_id, MAX(salary) AS salary_max\n    FROM Salaries\n    GROUP BY company_id) AS t\nON Salaries.company_id = t.company_id"
        }
      ]
    },
    {
      "section_id": "1479-sales-by-day-of-the-week--hard---leetcode",
      "id": 1479,
      "title": "Sales by Day of the Week",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/sales-by-day-of-the-week",
      "description": "You are the business owner and would like to obtain a sales report for category items and day of the week. Write an SQL query to report how many units in each category have been ordered on each day of the week. Return the result table ordered by category. The query result format is in the following example:",
      "tables": [
        "Orders",
        "Items"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH t1 AS(\nSELECT DISTINCT item_category,\nCASE WHEN dayname(order_date)='Monday' THEN SUM(quantity) OVER(PARTITION BY item_category,dayname(order_date)) ELSE 0 END AS Monday,\nCASE WHEN dayname(order_date)='Tuesday' THEN SUM(quantity) OVER(PARTITION BY item_category,dayname(order_date)) ELSE 0 END AS Tuesday,\nCASE WHEN dayname(order_date)='Wednesday' THEN SUM(quantity) OVER(PARTITION BY item_category,dayname(order_date)) ELSE 0 END AS Wednesday,\nCASE WHEN dayname(order_date)='Thursday' THEN SUM(quantity) OVER(PARTITION BY item_category,dayname(order_date)) ELSE 0 END AS Thursday,\nCASE WHEN dayname(order_date)='Friday' THEN SUM(quantity) OVER(PARTITION BY item_category,dayname(order_date)) ELSE 0 END AS Friday,\nCASE WHEN dayname(order_date)='Saturday' THEN SUM(quantity) OVER(PARTITION BY item_category,dayname(order_date)) ELSE 0 END AS Saturday,\nCASE WHEN dayname(order_date)='Sunday' THEN SUM(quantity) OVER(PARTITION BY item_category,dayname(order_date)) ELSE 0 END AS Sunday\nFROM orders o\nRIGHT JOIN items i\nUSING (item_id))\n\nSELECT item_category AS category, SUM(Monday) AS Monday, SUM(Tuesday) AS Tuesday, SUM(Wednesday) Wednesday, SUM(Thursday) Thursday,\nSUM(Friday) Friday, SUM(Saturday) Saturday, SUM(Sunday) Sunday\nFROM t1\nGROUP BY item_category"
        }
      ]
    },
    {
      "section_id": "1484-group-sold-products-by-the-date--easy---leetcode",
      "id": 1484,
      "title": "Group Sold Products By The Date",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/group-sold-products-by-the-date",
      "description": "Table Activities: Write an SQL query to find for each date, the number of distinct products sold and their names. The sold-products names for each date should be sorted lexicographically. Return the result table ordered by sell_date. The query result format is in the following example.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT sell_date, COUNT(DISTINCT product) AS num_sold, group_concat(DISTINCT product) AS products\nFROM activities\nGROUP BY 1\nORDER BY 1"
        }
      ]
    },
    {
      "section_id": "1495-friendly-movies-streamed-last-month--easy---leetcode",
      "id": 1495,
      "title": "Friendly Movies Streamed Last Month",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/friendly-movies-streamed-last-month",
      "description": "Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020. Return the result table in any order. The query result format is in the following example.",
      "tables": [
        "TVProgram",
        "Content"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELCT DISTINCT title\nFROM\n(SELCT content_id, title\nFROM content\nWHERE kids_content = 'Y' AND content_type = 'Movies') a\nJOIN\ntvprogram USING (content_id)\nWHERE month(program_date) = 6"
        }
      ]
    },
    {
      "section_id": "1501-countries-you-can-safely-invest-in--medium---leetcode",
      "id": 1501,
      "title": "Countries You Can Safely Invest In",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/countries-you-can-safely-invest-in",
      "description": "Table Person: Table Country: Table Calls: Write an SQL query to find the countries where this company can invest. Return the result table in any order. The query result format is in the following example.",
      "tables": [],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH t1 AS(\nSELECT caller_id AS id, duration AS total\nFROM\n(SELECT caller_id, duration\nFROM calls\nUNION ALL\nSELECT callee_id, duration\nFROM calls) a\n)\nSELECT name AS country\nFROM\n(SELECT distinct avg(total) OVER(PARTITION BY code) AS avg_call, avg(total) OVER() AS global_avg, c.name\nFROM\n((SELECT *, coalesce(total,0) AS duration, SUBSTRING(phone_number FROM 1 for 3) AS code\nFROM person RIGHT JOIN t1\nUSING (id)) b\njoin country c\nON c.country_code = b.code)) d\nWHERE avg_call > global_avg"
        }
      ]
    },
    {
      "section_id": "1511-customer-order-frequency--easy---leetcode",
      "id": 1511,
      "title": "Customer Order Frequency",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/customer-order-frequency",
      "description": "Write an SQL query to report the customer_id and customer_name of customers who have spent at least $100 in each month of June and July 2020. Return the result table in any order. The query result format is in the following example.",
      "tables": [
        "Customers",
        "Product",
        "Orders"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT o.customer_id, name\nJOIN Product p\nON o.product_id = p.product_id\nJOIN Customers c\nON o.customer_id = c.customer_id\nGROUP BY 1, 2\nHAVING SUM(CASE WHEN date_format(order_date, '%Y-%m')='2020-06'\nTHEN price*quantity END) >= 100\nAND\nSUM(CASE WHEN date_format(order_date, '%Y-%m')='2020-07'\nTHEN price*quantity END) >= 100;\n\n#Solution 2:\nSELECT customer_id, name\nFROM\n(\n    SELECT o.customer_id, c.name,\n        sum(CASE WHEN left(o.order_date,7) = '2020-06' THEN p.price * o.quantity END) AS JuneSpend,\n        sum(CASE WHEN left(o.order_date,7) = '2020-07' THEN p.price * o.quantity END) AS JulySpend\n    FROM Orders o\n    LEFT JOIN Customers c ON o.customer_id = c.customer_id\n    lEFT JOIN Product p ON o.product_id = p.product_id\n    GROUP BY o.customer_id\n    HAVING JuneSpend >= 100 AND JulySpend >= 100\n) AS temp\n\n#Solution 3:\nSELECT o.customer_id, c.name\nFROM Customers c, Product p, Orders o\nWHERE c.customer_id = o.customer_id AND p.product_id = o.product_id\nGROUP BY o.customer_id\nHAVING\n(\n    SUM(CASE WHEN o.order_date LIKE '2020-06%' THEN o.quantity*p.price ELSE 0 END) >= 100\n    and\n    SUM(CASE WHEN o.order_date LIKE '2020-07%' THEN o.quantity*p.price ELSE 0 END) >= 100\n);"
        }
      ]
    },
    {
      "section_id": "1517-find-users-with-valid-e-mails--easy---leetcode",
      "id": 1517,
      "title": "Find Users With Valid E-Mails",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-users-with-valid-e-mails",
      "description": "Write an SQL query to find the users who have valid emails. A valid e-mail has a prefix name and a domain where: The query result format is in the following example.",
      "tables": [
        "Users"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT user_id, name, mail\nFROM Users\nWHERE mail regexp \"^[a-zA-Z]+[a-zA-Z0-9_\\\\./\\\\-]{0,}@leetcode\\\\.com$\"\nORDER BY user_id\n\n#Solution 2:\nSELECT * FROM Users\nWHERE regexp_like(mail, '^[A-Za-z]+[A-Za-z0-9\\_\\.\\-]*@leetcode.com')"
        }
      ]
    },
    {
      "section_id": "1527-patients-with-a-condition--easy---leetcode",
      "id": 1527,
      "title": "Patients With a Condition",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/patients-with-a-condition",
      "description": "Write an SQL query to report the patient_id, patient_name all conditions of patients who have Type I Diabetes. Type I Diabetes always starts with DIAB1 prefix Return the result table in any order. The query result format is in the following example.",
      "tables": [
        "Patients"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT patient_id, patient_name, conditions\nFROM Patients\nWHERE conditions LIKE '%DIAB1%'"
        }
      ]
    },
    {
      "section_id": "1532-the-most-recent-three-orders--medium---leetcode",
      "id": 1532,
      "title": "The Most Recent Three Orders",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/the-most-recent-three-orders",
      "description": "Write an SQL query to find the most recent 3 orders of each user. If a user ordered less than 3 orders return all of their orders. Return the result table sorted by customer_name in ascending order and in case of a tie by the customer_id in ascending order. If there still a tie, order them by the order_date in descending order. The query result format is in the following example:",
      "tables": [
        "Customers",
        "Orders"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH tmp AS (\nSELECT a.name, a.customer_id, b.order_id, b.order_date,\nROW_NUMBER() OVER(PARTITION BY a.name, a.customer_id ORDER BY b.order_date DESC) AS rnk\nFROM Customers AS a\nJOIN Orders AS b\nON a.customer_id = b.customer_id\n)\n\nSELECT name AS customer_name, customer_id, order_id, order_date\nFROM tmp\nWHERE rnk <= 3\nORDER BY customer_name, customer_id, order_date DESC;"
        }
      ]
    },
    {
      "section_id": "1543-fix-product-name-format--easy---leetcode",
      "id": 1543,
      "title": "Fix Product Name Format",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/fix-product-name-format",
      "description": "Since table Sales was filled manually in the year 2000, product_name may contain leading and/or trailing white spaces, also they are case-insensitive. Write an SQL query to report The query result format is in the following example.",
      "tables": [
        "Sales"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT TRIM(LOWER(product_name)) AS product_name,\n       DATE_FORMAT(sale_date, '%Y-%m') AS sale_date,\n       COUNT(*) AS total\nFROM Sales\nGROUP BY 1, DATE_FORMAT(sale_date, '%Y-%m')\nORDER BY 1, 2;"
        }
      ]
    },
    {
      "section_id": "1549-the-most-recent-orders-for-each-product--medium---leetcode",
      "id": 1549,
      "title": "The Most Recent Orders for Each Product",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/the-most-recent-orders-for-each-product",
      "description": "Write an SQL query to find the most recent order(s) of each product. Return the result table sorted by product_name in ascending order and in case of a tie by the product_id in ascending order. If there still a tie, order them by the order_id in ascending order. The query result format is in the following example:",
      "tables": [
        "Customers",
        "Orders",
        "Products"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT p.product_name, o.product_id, o.order_id, o.order_date\nFROM(\n    SELECT product_id, order_id, order_date,\n    RANK() OVER(PARTITION BY product_id ORDER BY order_date DESC) AS seq\n    FROM orders\n) o\nLEFT JOIN products p\n    ON o.product_id = p.product_id\nWHERE o.seq = 1\nORDER BY 1,2,3"
        }
      ]
    },
    {
      "section_id": "1555-bank-account-summary--medium---leetcode",
      "id": 1555,
      "title": "Bank Account Summary",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/bank-account-summary",
      "description": "Leetcode Bank (LCB) helps its coders in making virtual payments. Our bank records all transactions in the table Transaction, we want to find out the current balance of all users and check wheter they have breached their credit limit (If their current credit is less than 0). Write an SQL query to report. The query result format is in the following example.",
      "tables": [
        "Users",
        "Transaction"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT Users.user_id AS user_id\n    , Users.user_name AS user_name\n    , credit+IFNULL(SUM(trans),0) AS credit\n    , CASE WHEN credit+IFNULL(SUM(trans),0)>0 THEN 'No' ELSE 'Yes' END AS credit_limit_breached\nFROM(\n    SELECT paid_by AS user_id, -amount AS trans\n    FROM Transaction\n    UNION ALL\n    SELECT paid_to AS user_id, amount AS trans\n    FROM Transaction\n) t RIGHT JOIN users ON t.user_id=users.user_id\nGROUP BY user_id"
        }
      ]
    },
    {
      "section_id": "1565-unique-orders-and-customers-per-month--easy---leetcode",
      "id": 1565,
      "title": "Unique Orders and Customers Per Month",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/unique-orders-and-customers-per-month",
      "description": "Write an SQL query to find the number of unique orders and the number of unique users with invoices > $20 for each different month. Return the result table sorted in any order. The query result format is in the following example:",
      "tables": [
        "Orders"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT DATE_FORMAT(order_date, '%Y-%m') AS month, COUNT(DISTINCT order_id) AS order_count, COUNT(DISTINCT customer_id) AS customer_count\n    FROM Orders\n    WHERE invoice > 20\n    GROUP BY YEAR(order_date), MONTH(order_date);\n\n#Solution 2:\nSELECT LEFT(order_date, 7) AS month, COUNT(DISTINCT order_id) AS order_count,\n\tCOUNT(DISTINCT customer_id) AS customer_count\nFROM orders\nWHERE invoice > 20\nGROUP BY month"
        }
      ]
    },
    {
      "section_id": "1571-warehouse-manager--easy---leetcode",
      "id": 1571,
      "title": "Warehouse Manager",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/warehouse-manager",
      "description": "Write an SQL query to report, How much cubic feet of volume does the inventory occupy in each warehouse. The query result format is in the following example.",
      "tables": [
        "Warehouse",
        "Products"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT a.name AS warehouse_name,\nSUM(a.units * b.Width * b.Length * b.Height) AS volume\nFROM Warehouse AS a\nLEFT JOIN Products AS b\nON a.product_id = b.product_id\nGROUP BY a.name;"
        }
      ]
    },
    {
      "section_id": "1581-customer-who-visited-but-did-not-make-any-transactions--easy---leetcode",
      "id": 1581,
      "title": "Customer Who Visited but Did Not Make Any Transactions",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions",
      "description": "Write an SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits. Return the result table sorted in any orders. The query result format is in the following example:",
      "tables": [
        "Visits",
        "Transactions"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT a.customer_id, COUNT(a.visit_id) AS count_no_trans FROM Visits AS a\nLEFT JOIN Transactions AS b\nON a.visit_id = b.visit_id\nWHERE b.transaction_id IS NULL\nGROUP BY a.customer_id;\n\n#Solution 2:\nSELECT customer_id, count(visit_id) AS count_no_trans\nFROM Visits\nWHERE visit_id NOT IN\n    (SELECT visit_id\n    FROM Transactions\n    GROUP BY visit_id)\nGROUP BY customer_id"
        }
      ]
    },
    {
      "section_id": "1587-bank-account-summary-ii--easy---leetcode",
      "id": 1587,
      "title": "Bank Account Summary II",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/bank-account-summary-ii",
      "description": "Write an SQL query to report the name and balance of users with a balance higher than 10000. The balance of an account is equal to the sum of the amounts of all transactions involving that account. Return the result table in any order. The query result format is in the following example.",
      "tables": [
        "Users",
        "Transactions"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT u.name AS NAME,SUM(t.amount) AS BALANCE\nFROM Transactions t LEFT JOIN Users u\nON u.account = t.account\nGROUP BY u.account\nHAVING SUM(t.amount)>10000;\n\n#Solution 2:\nWITH tmp AS(\nSELECT t.account, u.name, SUM(amount) AS balance\nFROM Transactions t\nLEFT JOIN Users u ON t.account = u.account\nGROUP BY account )\n\nSELECT name, balance\nFROM tmp\nWHERE balance > 10000"
        }
      ]
    },
    {
      "section_id": "1596-the-most-frequently-ordered-products-for-each-customer--medium---leetcode",
      "id": 1596,
      "title": "The Most Frequently Ordered Products for Each Customer",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/the-most-frequently-ordered-products-for-each-customer",
      "description": "Write an SQL query to find the most frequently ordered product(s) for each customer. The result table should have the product_id and product_name for each customer_id who ordered at least one order. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Customers",
        "Orders",
        "Products"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT customer_id, Products.product_id, Products.product_name FROM\n(SELECT customer_id, product_id, order_count, RANK() OVER(PARTITION BY customer_id ORDER BY order_count DESC) r From\n(SELECT customer_id, product_id, COUNT(DISTINCT order_id) AS order_count FROM Orders\nGROUP BY customer_id, product_id) order_counts) order_counts_ranked\nJOIN Products ON order_counts_ranked.product_id = Products.product_id\nWHERE r = 1;\n\n#solution- 2:\n\nSELECT customer_id, T.product_id, product_name\nFROM(\n    SELECT customer_id, product_id,\n    RANK() OVER( PARTITION BY customer_id ORDER BY COUNT(*) DESC ) AS RK\n    FROM Orders o\n    GROUP BY customer_id, product_id\n) T\nLEFT JOIN Products p on p.product_id = t.product_id\nWHERE RK=1\n\n#Solution-3:\n\nWITH\n\ntmp AS (\n  SELECT a.customer_id, b.product_id, c.product_name,\n  COUNT(b.order_id) OVER(PARTITION BY a.customer_id, b.product_id) AS freq\n  FROM Customers AS a\n  JOIN Orders AS b\n  ON a.customer_id = b.customer_id\n  JOIN Products AS c\n  ON b.product_id = c.product_id\n),\n\ntmp1 AS (\n  SELECT customer_id, product_id, product_name, freq,\n  DENSE_RANK() OVER(PARTITION BY customer_id ORDER BY freq DESC) AS rnk\n  FROM tmp\n)\n\nSELECT DISTINCT customer_id, product_id, product_name FROM tmp1\nWHERE rnk = 1;"
        }
      ]
    },
    {
      "section_id": "1607-sellers-with-no-sales--easy---leetcode",
      "id": 1607,
      "title": "Sellers With No Sales",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/sellers-with-no-sales",
      "description": "Write an SQL query to report the names of all sellers who did not make any sales in 2020. Return the result table ordered by seller_name in ascending order. The query result format is in the following example.",
      "tables": [
        "Customer",
        "Orders",
        "Seller"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT seller_name FROM Seller\nWHERE seller_id NOT IN (\nSELECT DISTINCT seller_id FROM Orders\nWHERE YEAR(sale_date)='2020'\n)\nORDER BY seller_name;"
        }
      ]
    },
    {
      "section_id": "1613-find-the-missing-ids--medium---leetcode",
      "id": 1613,
      "title": "Find the Missing IDs",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-the-missing-ids",
      "description": "Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table. Notice that the maximum customer_id will not exceed 100. Return the result table ordered by ids in ascending order. The query result format is in the following example.",
      "tables": [
        "Customers"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH RECURSIVE CTE AS(\n    SELECT 1 AS 'id', MAX(c.customer_id) AS 'Max_Id'\n    FROM Customers c\n    UNION ALL\n    SELECT id+1, Max_Id\n    FROM CTE\n    WHERE id < Max_id\n)\n\nSELECT id AS 'ids'\nFROM CTE c\nWHERE c.id NOT IN (SELECT customer_id FROM Customers)\nORDER BY 1 ASC"
        }
      ]
    },
    {
      "section_id": "1623-all-valid-triplets-that-can-represent-a-country--easy---leetcode",
      "id": 1623,
      "title": "All Valid Triplets That Can Represent a Country",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/all-valid-triplets-that-can-represent-a-country",
      "description": "There is a country with three schools, where each student is enrolled in exactly one school. The country is joining a competition and wants to select one student from each school to represent the country such that: Return the result table in any order. The query result format is in the following example.",
      "tables": [
        "SchoolA",
        "SchoolB",
        "SchoolC"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT a.student_name AS 'member_A',\nb.student_name AS 'member_B',\nc.student_name AS 'member_C'\nFROM SchoolA AS a\nJOIN SchoolB AS b\nON a.student_id <> b.student_id\nAND a.student_name <> b.student_name\nJOIN SchoolC AS c\nON a.student_id <> c.student_id\nAND b.student_id <> c.student_id\nAND a.student_name <> c.student_name\nAND b.student_name <> c.student_name;"
        }
      ]
    },
    {
      "section_id": "1633-percentage-of-users-attended-a-contest--easy---leetcode",
      "id": 1633,
      "title": "Percentage of Users Attended a Contest",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/percentage-of-users-attended-a-contest",
      "description": "Write an SQL query to find the percentage of the users registered in each contest rounded to two decimals. Return the result table ordered by percentage in descending order. In case of a tie, order it by contest_id in ascending order. The query result format is in the following example.",
      "tables": [
        "Users",
        "Register"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT contest_id, ROUND(COUNT(user_id)*100.00/(SELECT COUNT(*) FROM users),2) as percentage\nFROM register\nGROUP BY contest_id\nORDER BY percentage desc, contest_id"
        }
      ]
    },
    {
      "section_id": "1635-hopper-company-queries-i--hard---leetcode",
      "id": 1635,
      "title": "Hopper Company Queries I",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/hopper-company-queries-i",
      "description": "Write an SQL query to report the following statistics for each month of 2020: The number of drivers currently with the Hopper company by the end of the month (active_drivers). The number of accepted rides in that month (accepted_rides). Return the result table ordered by month in ascending order, where month is the month's number (January is 1, February is 2, etc.). The query result format is in the following example.",
      "tables": [
        "Drivers",
        "Rides",
        "AcceptedRides"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT t.month,\n    COUNT(DISTINCT driver_id) active_drivers,\n    COUNT(DISTINCT rides.ride_id) accepted_rides\nFROM\n    ((SELECT 1 AS month)\n    UNION (SELECT 2 AS month)\n    UNION (SELECT 3 AS month)\n    UNION (SELECT 4 AS month)\n    UNION (SELECT 5 AS month)\n    UNION (SELECT 6 AS month)\n    UNION (SELECT 7 AS month)\n    UNION (SELECT 8 AS month)\n    UNION (SELECT 9 AS month)\n    UNION (SELECT 10 AS month)\n    UNION (SELECT 11 AS month)\n    UNION (SELECT 12 AS month)) t\nLEFT JOIN\n    (SELECT driver_id,\n    (CASE WHEN year(join_date) = 2019 THEN '1' ELSE month(join_date) END) `month`\n    FROM Drivers\n    WHERE year(join_date) <= 2020) d\nON d.month <= t.month\nLEFT JOIN\n    (SELECT month(requested_at) AS `month`, a.ride_id\n    FROM AcceptedRides a\n    JOIN Rides r\n    ON r.ride_id = a.ride_id\n    WHERE year(requested_at) = 2020) rides\nON t.month = rides.month\nGROUP BY t.month\nORDER BY t.month"
        }
      ]
    },
    {
      "section_id": "1645-hopper-company-queries-ii--hard---leetcode",
      "id": 1645,
      "title": "Hopper Company Queries II",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/hopper-company-queries-ii",
      "description": "Write an SQL query to report the percentage of working drivers (working_percentage) for each month of 2020 where: Note that if the number of available drivers during a month is zero, we consider the working_percentage to be 0. Return the result table ordered by month in ascending order, where month is the month's number (January is 1, February is 2, etc.). Round working_percentage to the nearest 2 decimal places. The query result format is in the following example.",
      "tables": [
        "Drivers",
        "Rides",
        "AcceptedRides"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT months_drivers.month, ROUND(COALESCE(100 * COALESCE(total_active_drivers, 0) / total_drivers, 0), 2) AS working_percentage\nFROM\n(\n    SELECT month, COUNT(driver_id) AS total_drivers\n    FROM Drivers AS a\n    RIGHT JOIN\n    (\n        SELECT \"2020-1-31\" AS day, 1 AS month\n        UNION SELECT \"2020-2-29\", 2\n        UNION SELECT \"2020-3-31\", 3\n        UNION SELECT \"2020-4-30\", 4\n        UNION SELECT \"2020-5-31\", 5\n        UNION SELECT \"2020-6-30\", 6\n        UNION SELECT \"2020-7-31\", 7\n        UNION SELECT \"2020-8-31\", 8\n        UNION SELECT \"2020-9-30\", 9\n        UNION SELECT \"2020-10-31\", 10\n        UNION SELECT \"2020-11-30\", 11\n        UNION SELECT \"2020-12-31\", 12\n    ) AS months\n    ON join_date <= day\n    GROUP BY month\n) months_drivers\nLEFT JOIN\n(\n    SELECT month, COUNT(DISTINCT b.driver_id) AS total_active_drivers\n    FROM\n    (\n        SELECT ride_id, CAST(substr(requested_at, 6, 2) AS unsigned) AS month\n        FROM Rides\n        WHERE substr(requested_at, 1, 4) = \"2020\"\n    ) month_rides\n    JOIN AcceptedRides AS b\n    ON month_rides.ride_id = b.ride_id\n    GROUP BY month\n) months_active_drivers\nON months_drivers.month = months_active_drivers.month;"
        }
      ]
    },
    {
      "section_id": "1651-hopper-company-queries-iii--hard---leetcode",
      "id": 1651,
      "title": "Hopper Company Queries III",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/hopper-company-queries-iii",
      "description": "Write an SQL query to compute the average_ride_distance and average_ride_duration of every 3-month window starting from January - March 2020 to October - December 2020. Round average_ride_distance and average_ride_duration to the nearest two decimal places. The average_ride_distance is calculated by summing up the total ride_distance values from the three months and dividing it by 3. The average_ride_duration is calculated in a similar way. Return the result table ordered by month in ascending order, where month is the starting month's number (January is 1, February is 2, etc.). The query result format is in the following example.",
      "tables": [
        "Drivers",
        "Rides",
        "AcceptedRides"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT month,\n    COALESCE(ROUND(SUM(ride_distance)/3,2),0) AS average_ride_distance,\n    COALESCE(ROUND(SUM(ride_duration)/3,2),0) AS average_ride_duration\nFROM\n(\n    SELECT months.month, ride_id\n    FROM Rides\n    RIGHT JOIN\n    (\n        SELECT \"2020-1-1\" AS start, \"2020-3-31\" AS last, 1 AS month\n        UNION SELECT \"2020-2-1\", \"2020-4-30\", 2\n        UNION SELECT \"2020-3-1\", \"2020-5-31\", 3\n        UNION SELECT \"2020-4-1\", \"2020-6-30\", 4\n        UNION SELECT \"2020-5-1\", \"2020-7-31\", 5\n        UNION SELECT \"2020-6-1\", \"2020-8-31\", 6\n        UNION SELECT \"2020-7-1\", \"2020-9-30\", 7\n        UNION SELECT \"2020-8-1\", \"2020-10-31\", 8\n        UNION SELECT \"2020-9-1\", \"2020-11-30\", 9\n        UNION SELECT \"2020-10-1\", \"2020-12-31\", 10\n    ) AS months\n    ON months.start <= requested_at AND months.last >= requested_at\n) total\nLEFT JOIN AcceptedRides AS a\nON total.ride_id=a.ride_id\nGROUP BY month\nORDER BY month;"
        }
      ]
    },
    {
      "section_id": "1661-average-time-of-process-per-machine--easy---leetcode",
      "id": 1661,
      "title": "Average Time of Process per Machine",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/average-time-of-process-per-machine",
      "description": "There is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process. The time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run. The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places. The query result format is in the following example:",
      "tables": [
        "Activity"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT machine_id,\n\tROUND(SUM(IF(activity_type='start', -timestamp, timestamp)) / COUNT(DISTINCT process_id), 3) AS processing_time\nFROM Activity\nGROUP BY machine_id\nORDER BY machine_id"
        }
      ]
    },
    {
      "section_id": "1667-fix-names-in-a-table--easy---leetcode",
      "id": 1667,
      "title": "Fix Names in a Table",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/fix-names-in-a-table",
      "description": "Write an SQL query to fix the names so that only the first character is uppercase and the rest are lowercase. Return the result table ordered by user_id. The query result format is in the following example:",
      "tables": [
        "Users"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "select user_id,\n    CONCAT(UPPER(LEFT(name,1)),LOWER(SUBSTRING(name,2))) AS name\nFROM Users\nORDER BY user_id"
        }
      ]
    },
    {
      "section_id": "1677-products-worth-over-invoices--easy---leetcode",
      "id": 1677,
      "title": "Product's Worth Over Invoices",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/products-worth-over-invoices",
      "description": "Write an SQL query that will, for all products, return each product name with total amount due, paid, canceled, and refunded across all invoices. Return the result table ordered by product_name. The query result format is in the following example:",
      "tables": [
        "Product",
        "Invoice"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT p.name AS name,\n    SUM(i.rest) AS rest,\n    SUM(i.paid) AS paid,\n    SUM(i.canceled) AS canceled,\n    SUM(i.refunded) AS refunded\nFROM Invoice i\nLEFT JOIN Product p ON p.product_id = i.product_id\nGROUP BY name\nORDER BY name;"
        }
      ]
    },
    {
      "section_id": "1683-invalid-tweets--easy---leetcode",
      "id": 1683,
      "title": "Invalid Tweets",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/invalid-tweets",
      "description": "Write an SQL query to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Tweets"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT tweet_id\nFROM Tweets\nWHERE LENGTH(content) > 15;"
        }
      ]
    },
    {
      "section_id": "1693-daily-leads-and-partners--easy---leetcode",
      "id": 1693,
      "title": "Daily Leads and Partners",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/daily-leads-and-partners",
      "description": "Write an SQL query that will, for each date_id and make_name, return the number of distinct lead_id's and distinct partner_id's. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "DailySales"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT date_id, make_name,\n    COUNT(DISTINCT lead_id) AS unique_leads,\n    COUNT(DISTINCT partner_id) AS unique_partners\nFROM DailySales\nGROUP BY date_id, make_name"
        }
      ]
    },
    {
      "section_id": "1699-number-of-calls-between-two-persons--medium---leetcode",
      "id": 1699,
      "title": "Number of Calls Between Two Persons",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/number-of-calls-between-two-persons",
      "description": "Write an SQL query to report the number of calls and the total call duration between each pair of distinct persons (person1, person2) where person1 < person2. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Calls"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT from_id AS person1,to_id AS person2,\n    COUNT(duration) AS call_count, SUM(duration) AS total_duration\nFROM (SELECT *\n      FROM Calls\n\n      UNION ALL\n\n      SELECT to_id, from_id, duration\n      FROM Calls) t1\nWHERE from_id < to_id\nGROUP BY person1, person2\n\n#Solution 2:\nSELECT\n    IF(from_id<to_id,from_id,to_id) person1,\n    IF(from_id>to_id,from_id,to_id) person2,\n    COUNT(*) call_count,\n    SUM(duration) total_duration\nFROM\n    Calls\nGROUP BY\n    IF(from_id<to_id,from_id,to_id),\n    IF(from_id>to_id,from_id,to_id);"
        }
      ]
    },
    {
      "section_id": "1709-biggest-window-between-visits--medium---leetcode",
      "id": 1709,
      "title": "Biggest Window Between Visits",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/biggest-window-between-visits",
      "description": "Assume today's date is '2021-1-1'. Write an SQL query that will, for each user_id, find out the largest window of days between each visit and the one right after it (or today if you are considering the last visit). Return the result table ordered by user_id. The query result format is in the following example:",
      "tables": [
        "UserVisits"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT user_id, max(diff) AS biggest_window\nFROM\n(\n    SELECT user_id,\n       datediff(coalesce(lead(visit_date) OVER (PARTITION BY user_id ORDER BY visit_date), '2021-01-01'), visit_date) AS diff\n    FROM userVisits\n) t\nGROUP BY user_id\nORDER BY user_id"
        }
      ]
    },
    {
      "section_id": "1715-count-apples-and-oranges--medium---leetcode",
      "id": 1715,
      "title": "Count Apples and Oranges",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/count-apples-and-oranges",
      "description": "Write an SQL query to count the number of apples and oranges in all the boxes. If a box contains a chest, you should also include the number of apples and oranges it has. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Boxes",
        "Chests"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT sum(IFNULL(box.apple_count, 0) + IFNULL(chest.apple_count, 0)) AS apple_count,\n    sum(IFNULL(box.orange_count, 0) + IFNULL(chest.orange_count, 0)) AS orange_count\n    FROM Boxes AS box\n    LEFT JOIN Chests AS chest\n    ON box.chest_id = chest.chest_id;"
        }
      ]
    },
    {
      "section_id": "1729-find-followers-count--easy---leetcode",
      "id": 1729,
      "title": "Find Followers Count",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-followers-count",
      "description": "Write an SQL query that will, for each user, return the number of followers. Return the result table ordered by user_id. The query result format is in the following example:",
      "tables": [
        "Followers"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT user_id, COUNT(DISTINCT follower_id) followers_count\nFROM followers\nGROUP BY user_id\nORDER BY user_id"
        }
      ]
    },
    {
      "section_id": "1731-the-number-of-employees-which-report-to-each-employee--easy---leetcode",
      "id": 1731,
      "title": "The Number of Employees Which Report to Each Employee",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/the-number-of-employees-which-report-to-each-employee",
      "description": "For this problem, we will consider a manager an employee who has at least 1 other employee reporting to them. Write an SQL query to report the ids and the names of all managers, the number of employees who report directly to them, and the average age of the reports rounded to the nearest integer. Return the result table ordered by employee_id. The query result format is in the following example:",
      "tables": [
        "Employees"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT e1.reports_to AS employee_id,\n       e2.name,\n       COUNT(e1.reports_to) AS reports_count,\n       ROUND(AVG(e1.age),0) AS average_age\nFROM employees e1\nJOIN employees e2\nON e1.reports_to=e2.employee_id\nGROUP BY e1.reports_to\nORDER BY e1.reports_to"
        }
      ]
    },
    {
      "section_id": "1741-find-total-time-spent-by-each-employee--easy---leetcode",
      "id": 1741,
      "title": "Find Total Time Spent by Each Employee",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-total-time-spent-by-each-employee",
      "description": "Write an SQL query to calculate the total time in minutes spent by each employee on each day at the office. Note that within one day, an employee can enter and leave more than once. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Employees"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT event_day AS day, emp_id, SUM(out_time - in_time) AS total_time\nFROM Employees\nGROUP BY day, emp_id"
        }
      ]
    },
    {
      "section_id": "1747-leetflex-banned-accounts--medium---leetcode",
      "id": 1747,
      "title": "Leetflex Banned Accounts",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/leetflex-banned-accounts",
      "description": "Write an SQL query to find the account_id of the accounts that should be banned from Leetflex. An account should be banned if it was logged in at some moment from two different IP addresses. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "LogInfo"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT DISTINCT l1.account_id\nFROM LogInfo l1\nJOIN LogInfo l2\nON l1.account_id = l2.account_id AND l1.ip_address != l2.ip_address\nWHERE NOT (l1.login > l2.logout OR l1.logout < l2.login)"
        }
      ]
    },
    {
      "section_id": "1757-recyclable-and-low-fat-products--easy---leetcode",
      "id": 1757,
      "title": "Recyclable and Low Fat Products",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/recyclable-and-low-fat-products",
      "description": "Write an SQL query to find the ids of products that are both low fat and recyclable. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Products"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT product_id\nFROM Products\nWHERE low_fats = \"Y\" AND recyclable = \"Y\""
        }
      ]
    },
    {
      "section_id": "1767-find-the-subtasks-that-did-not-execute--hard---leetcode",
      "id": 1767,
      "title": "Find the Subtasks That Did Not Execute",
      "difficulty": "Hard",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/find-the-subtasks-that-did-not-execute",
      "description": "Write an SQL query to report the IDs of the missing subtasks for each task_id. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Tasks",
        "Executed"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "WITH RECURSIVE CTE AS\n  (SELECT 1 AS subtask_id\n   UNION ALL SELECT subtask_id + 1\n   FROM CTE\n   WHERE subtask_id <\n       (SELECT MAX(subtasks_count)\n        FROM Tasks) )\nSELECT Tasks.task_id,\n       CTE.subtask_id\nFROM CTE\nINNER JOIN Tasks ON CTE.subtask_id <= Tasks.subtasks_count\nLEFT JOIN Executed ON Tasks.task_id = Executed.task_id\n                      AND CTE.subtask_id = Executed.subtask_id\nWHERE Executed.subtask_id IS NULL\nORDER BY NULL"
        }
      ]
    },
    {
      "section_id": "1777-products-price-for-each-store--easy---leetcode",
      "id": 1777,
      "title": "Product's Price for Each Store",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/products-price-for-each-store",
      "description": "Write an SQL query to find the price of each product in each store. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Products"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "SELECT product_id,\n       SUM(CASE WHEN store='store1' THEN price END) AS store1,\n       SUM(CASE WHEN store='store2' THEN price END) AS store2,\n       SUM(CASE WHEN store='store3' THEN price END) AS store3\nFROM Products\nGROUP BY product_id"
        }
      ]
    },
    {
      "section_id": "1783-grand-slam-titles--medium---leetcode",
      "id": 1783,
      "title": "Grand Slam Titles",
      "difficulty": "Medium",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/grand-slam-titles",
      "description": "Write an SQL query to report the number of grand slam tournaments won by each player. Do not include the players who did not win any tournament. Return the result table in any order. The query result format is in the following example:",
      "tables": [
        "Players",
        "Championships"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT player_id, player_name,\n\tSUM((IF(Wimbledon = player_id,1,0) +\n\t\tIF(Fr_open = player_id,1,0) +\n\t\tIF(US_open = player_id,1,0) +\n\t\tIF(Au_open = player_id,1,0))) as grand_slams_count\nFROM Players INNER JOIN Championships\nON Wimbledon = player_id OR Fr_open = player_id OR US_open = player_id OR Au_open = player_id\nGROUP BY player_id;\n\n#Solution 2:\nWITH cte\n     AS (SELECT wimbledon AS id\n         FROM   championships\n         UNION ALL\n         SELECT fr_open AS id\n         FROM   championships\n         UNION ALL\n         SELECT us_open AS id\n         FROM   championships\n         UNION ALL\n         SELECT au_open AS id\n         FROM   championships)\nSELECT player_id,\n       player_name,\n       Count(*) AS grand_slams_count\nFROM   players\n       INNER JOIN cte\n               ON players.player_id = cte.id\nGROUP  BY 1, 2\nORDER  BY NULL;"
        }
      ]
    },
    {
      "section_id": "1789-primary-department-for-each-employee--easy---leetcode",
      "id": 1789,
      "title": "Primary Department for Each Employee",
      "difficulty": "Easy",
      "locked": true,
      "leetcode_url": "https://leetcode.com/problems/primary-department-for-each-employee",
      "description": "Employees can belong to multiple departments. When the employee joins other departments, they need to decide which department is their primary department. Note that when an employee belongs to only one department, their primary column is 'N'. Write an SQL query to report all the employees with their primary department. For employees who belong to one department, report their only department. Return the result table in any order. The query result format is in the following example.",
      "tables": [
        "Employee"
      ],
      "solutions": [
        {
          "label": "Solution 1",
          "sql": "#Solution 1:\nSELECT employee_id,department_id\nFROM employee\nWHERE primary_flag = 'Y' OR employee_id IN\n    (SELECT employee_id\n     FROM employee\n     GROUP BY employee_id\n     HAVING COUNT(department_id) = 1)\n\n#Solution 2:\n(SELECT employee_id,\n      department_id\nFROM Employee\nWHERE primary_flag = 'Y')\nUNION\n(SELECT employee_id,\n      department_id\nFROM Employee\nGROUP BY employee_id\nHAVING COUNT(employee_id) = 1\nORDER BY NULL);"
        }
      ]
    }
  ]
}
